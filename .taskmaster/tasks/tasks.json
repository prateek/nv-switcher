{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project scaffolding, build, and CI setup",
        "description": "Initialize Obsidian plugin project with TypeScript, tsup bundling to a single main.js, testing (Vitest + JSDOM), linting, and GitHub Actions CI for typecheck, test, build, and release zip.",
        "details": "Implementation:\n- Files: manifest.json, package.json, tsconfig.json, tsup.config.ts, .eslintrc, .prettierrc, vitest.config.ts, src/plugin.ts, src/styles.css, README.md, LICENSE (MIT).\n- manifest.json: { id: \"obsidian-nv-switcher\", name: \"nv-switcher\", version: \"1.0.0\", minAppVersion: \"1.5.0\", author, main: \"main.js\", description }.\n- package.json devDeps: obsidian (types), typescript, tsup, vitest, @vitest/ui, jsdom, eslint, @typescript-eslint/*, esbuild.\n- tsup: entry src/plugin.ts, format iife, globalName plugin, minify, sourcemap, target es2020, define process.env.NODE_ENV.\n- plugin.ts exports default class NvSwitcherPlugin extends Plugin { async onload() { ... } async onunload() { ... } }.\n- GitHub Actions: workflow to install deps, build, run tests, upload artifact (main.js, manifest.json, styles.css) as release asset on tag.\n- CSS: define --nv-switcher-highlight-color var fallback to theme.\nPseudo-code:\nclass NvSwitcherPlugin extends Plugin {\n  settings: Settings;\n  async onload() {\n    await this.loadSettings();\n    this.addSettingTab(new NvSwitcherSettingsTab(this.app, this));\n    this.registerCommands();\n  }\n  async loadSettings(){ this.settings = Object.assign(DEFAULT_SETTINGS, await this.loadData()); }\n  async saveSettings(){ await this.saveData(this.settings); }\n}\n",
        "testStrategy": "Validation:\n- Build: tsup builds single main.js; verify manifest fields.\n- CI: PR triggers typecheck, lint, tests; tag v1.0.0 creates release artifact.\n- Unit: sanity tests load plugin class with mock app.\n- Manual: load plugin in Obsidian sandbox vault to ensure it appears and loads without errors.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Settings schema and SettingsTab UI",
        "description": "Implement comprehensive settings model and SettingsTab UI per PRD (.taskmaster/docs/prd.md), covering General, Search, Preview, Commands mode, and Hotkeys/Keyboard customization with reactive storage, validation, and migrations.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "details": "Source of truth: Use .taskmaster/docs/prd.md (section 8: Settings; section 3: Keyboard; plus related snippets/preview constraints from other sections) for field names, defaults, ranges, and behavior. Where PRD is silent, retain existing defaults.\n\nImplementation:\n- Define Settings interface and DEFAULT_SETTINGS with schemaVersion and complete field mapping as per PRD:\n  schemaVersion: number (start at 1). Used for migrations.\n  general:\n    - openHotkey: string (keyboard chord; default as specified in PRD Keyboard section; fallback Mod+K or ⌘N if not specified).\n    - createLocation: 'root' | 'same' | 'fixed'.\n    - fixedFolder: string (validated; create if missing when selected).\n    - includeCodeBlocks: boolean (default false).\n    - maxResults: number (default 100; min/max bounds per PRD).\n    - debounceMs: number (search input debounce; per PRD, default e.g., 80–150ms range; clamp to [20, 500]).\n    - minQueryLength: number (default 1; clamp to [0, 10]).\n  search:\n    - backend: 'built-in' | 'auto' | 'omni' (per PRD terminology; wire to providers).\n    - weights: { title, headings, path, tags, symbols, body, recency } numbers mapping directly to scorer weights.\n    - diacritics: boolean (default true; fold accents if true).\n    - regexCandidateK: number (default 300; clamp to reasonable bounds, e.g., [50, 2000]).\n    - recencyHalfLifeDays: number (maps to decay used by scorer; PRD value; clamp to [1, 365]).\n    - excludeFolders: string[] (folder paths or glob-like patterns; normalized; used by indexer/search to ignore).\n  preview:\n    - inlineSnippet: boolean (default true).\n    - fragmentLength: number (default 120; clamp to [60, 240] as per PRD/tests).\n    - maxFragments: number (default 3; clamp to [1, 5]).\n    - showFrontmatter: boolean (default false).\n    - showTags: boolean (default true).\n    - showPath: boolean (default true).\n    - highlightCssVar: string (default \"--nv-switcher-highlight-color\").\n    - highlightColor: string (CSS color value; default per PRD; if set, write to documentElement.style for highlightCssVar).\n  commands:\n    - enableCommandsPrefix: boolean (default true; gates \">\" router per PRD).\n    - commandsPrefixChar: string (default '>' per PRD; single visible char; validated non-empty).\n    - showCommandIds: boolean (default false).\n    - openInSplitModifier: 'mod' | 'alt' | 'shift' | 'ctrl' (default per PRD; used to interpret modified open action).\n  keyboard:\n    - chordSeparator: string (default '+', from PRD Keybinding grammar).\n    - platformMetaKey: 'mod' | 'cmdCtrl' (internal helper reflecting PRD guidance; affects display).\n  hotkeys: Record<string, string[]> mapping modal actions to arrays of keyboard chords (strings). Actions include at minimum: moveUp, moveDown, open, forceCreate, openInSplit, focusPreview, cycleLeft, cycleRight, close, toggleCommandsMode, clearQuery, acceptSelection. Defaults must match PRD section 3 per platform (Cmd on macOS, Ctrl on Windows/Linux). Ensure chords follow PRD grammar (e.g., Mod+Enter, Shift+Tab, Ctrl+J, etc.).\n\n- Settings storage:\n  - Reactive load/save on plugin init and SettingsTab changes; debounce saves using requestIdleCallback or setTimeout (~150ms) to avoid churn.\n  - Add migrateSettings(prev: any): Settings that upgrades based on schemaVersion (e.g., v0 -> v1 adds debounceMs, minQueryLength, recencyHalfLifeDays, commandsPrefixChar, highlightColor, keyboard, excludeFolders). Never mutate previous object in-place; return a new Settings with defaults for new fields.\n\n- Validation:\n  - fixedFolder: normalize path; verify or create when createLocation === 'fixed'. Show inline error in SettingsTab if invalid; disable save/selection when invalid.\n  - Numeric ranges: clamp values to PRD-defined ranges; show helper text with ranges under sliders.\n  - commandsPrefixChar: require single non-whitespace glyph; cannot conflict with hotkey chords typing (per PRD notes). If changed, reflect in input router behavior.\n  - hotkeys: parse/normalize chords (case-insensitive keys, normalized modifiers order per PRD). Detect conflicts between actions; render warnings and allow override/reset.\n  - excludeFolders: validate entries; trim; ignore duplicates.\n\n- SettingsTab UI (PluginSettingTab):\n  - Render sections: General, Search, Preview, Commands, Keyboard & Hotkeys (grouped as per PRD). Use toggles, text inputs, dropdowns, sliders with labels/tooltips sourced from PRD copy.\n  - Bind controls to plugin.settings; onChange -> validate -> set -> debounced save.\n  - Hotkeys editor: show list of actions with current chords; add/remove/reset per PRD; indicate platform defaults; show conflict badges.\n  - Weights sliders map to numeric values and persist; provide reset-to-PRD-defaults button per section.\n  - Commands: input for prefix char; toggle enable; toggle showCommandIds; dropdown for split modifier.\n  - Preview: controls for fragmentLength, maxFragments, highlightCssVar, highlightColor; on change, apply CSS var to documentElement; on unload, remove previously set var.\n\n- Expose getters/helpers:\n  - toScorerConfig(): translates settings.search.weights, diacritics, recencyHalfLifeDays into scorer module configuration.\n  - isCommandsQuery(input: string): checks prefix based on enableCommandsPrefix and commandsPrefixChar.\n  - getNormalizedHotkeys(): returns platform-specific chords expanded and normalized for use in modal.\n\n- CSS var application:\n  - On load and whenever preview.highlightColor or preview.highlightCssVar changes, set document.documentElement.style.setProperty(highlightCssVar, highlightColor). On unload/reset, removeProperty.\n\nPseudo-code:\ninterface Settings { schemaVersion: number; general: {...}; search: {...}; preview: {...}; commands: {...}; keyboard: {...}; hotkeys: Record<string, string[]> }\nfunction migrateSettings(prev:any): Settings { /* add missing fields with PRD defaults; bump schemaVersion */ }\nclass NvSwitcherSettingsTab extends PluginSettingTab { display(){ /* build UI per PRD; bind, validate, debounce save */ } }\n",
        "testStrategy": "Unit:\n- Load/save roundtrip with DEFAULT_SETTINGS including new fields (schemaVersion, debounceMs, minQueryLength, recencyHalfLifeDays, commandsPrefixChar, highlightColor, excludeFolders, keyboard). Unknown fields preserved; missing fields filled with defaults via migrateSettings.\n- Migration: simulate old settings (v0) and ensure migrateSettings returns v1 with correct defaults; no data loss for existing fields.\n- Validation: fixedFolder path normalization/creation; numeric clamping for fragmentLength [60,240], maxFragments [1,5], regexCandidateK bounds, debounceMs bounds; commandsPrefixChar single-glyph requirement; excludeFolders sanitized.\n- Keyboard/Hotkeys:\n  - Normalize \"mod\" to Cmd/Ctrl per platform; parse chords order; detect conflicts; ensure defaults match PRD section 3.\n  - openInSplitModifier behavior: verify interpretation in key handling helper.\n- Commands router: when enableCommandsPrefix=true and commandsPrefixChar='>', input starting with '>' routes to commands; when disabled or char changed, router honors setting.\n- Weights: ensure sliders map to numeric values and persist within ranges; toScorerConfig() produces expected shape for scorer module.\n- CSS: setting highlightCssVar/highlightColor writes to documentElement.style and removes on unload.\n\nUI (JSDOM):\n- Render SettingsTab and simulate user interactions: toggling diacritics/includeCodeBlocks; editing commandsPrefixChar; adjusting sliders; adding/removing hotkey chords; adding excludeFolders. Assert plugin.settings reflects changes and debounced saves occur (spy on saveSettings).\n- Snapshot critical UI groups (General, Search/weights, Preview, Commands, Hotkeys) for structure and labels per PRD.\n",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Settings types, DEFAULT_SETTINGS, and schemaVersion per PRD",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement migrateSettings(prev) to upgrade legacy settings to v1",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build SettingsTab UI with sections and controls mapped to PRD fields",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement validation for paths, numeric ranges, prefix char, and hotkey conflicts",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Apply highlight CSS variable on load/changes and clean up on unload",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Expose helpers: toScorerConfig, isCommandsQuery, getNormalizedHotkeys",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Write unit and JSDOM tests for settings, UI bindings, keyboard, and migrations",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Commands registration and Hotkey handling",
        "description": "Register plugin commands and wire default hotkeys; centralize in-modal hotkey mapping with customizable bindings from Settings.",
        "details": "Implementation:\n- Register commands via this.addCommand for:\n  - nv-switcher:open (default ⌘N): opens modal.\n  - nv-switcher:toggle-inline-snippet (unassigned): toggles preview.inlineSnippet setting.\n- For in-modal actions (J/K, Tab, Esc, Alt←/→, Shift+Enter, Cmd+Enter): implement a HotkeyManager reading plugin.settings.hotkeys and matching KeyboardEvent using Obsidian's Keymap.isModifier and Platform.isMacOS.\n- Cross-platform: map 'mod' to Meta on macOS, Ctrl elsewhere.\n- Open in split: in modal, when openInSplit action or mod+Enter, open in new leaf.\nPseudo-code:\nthis.addCommand({ id:'open', name:'Open nv-switcher', hotkeys:[{ modifiers:['Mod'], key:'n' }], callback:()=> new NvModal(this.app, this).open() })\nfunction matchHotkey(evt: KeyboardEvent, accel: string){ /* parse 'Mod-Enter', 'Shift-Enter', 'Alt-ArrowLeft' etc. */ }\n",
        "testStrategy": "Integration (JSDOM):\n- Press mod+N opens modal instance.\n- In modal, simulate mapped keys to navigate and open.\n- Rebinding in settings updates behavior at runtime.\n- Verify open-in-split opens file in new leaf using workspace.getLeaf(true).",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Search types and provider interface",
        "description": "Define types for Doc, ParsedQuery, SearchResult, and the SearchProvider interface to enable provider swapping.",
        "details": "Implementation:\n- Types:\n  type Doc = { id: string; title: string; path: string[]; tags: string[]; headings: string[]; symbols: string[]; body: string; mtime: number; size: number };\n  type ParsedQuery = { raw: string; mode: 'files'|'commands'; terms: string[]; phrases: string[]; excludes: string[]; orGroups: string[][]; filters: { tag?: string[]; path?: string[]; in?: string[]; field?: 'headings'|'symbols' }; regex?: { source:string; flags:string } };\n  type MatchSpan = { field: keyof Doc, start: number, end: number };\n  type SearchResult = { id: string; score: number; matchSpans: MatchSpan[] };\n- SearchProvider interface as in PRD with Promise signatures.\n- Export discriminated unions for provider selection (BuiltInProvider default).\n- Utilities: normalizeText(str, diacritics:boolean): lowercases + NFD strip if enabled.\n",
        "testStrategy": "Unit:\n- Type-level tests via tsd or compile checks.\n- Runtime guards: narrow ParsedQuery fields; ensure SearchResult schema contains required fields.\n- Contract tests: mock provider implementing interface, consumed by modal without knowledge of implementation.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define core search domain types",
            "description": "Create and export TypeScript types for Doc, ParsedQuery, MatchSpan, and SearchResult with comprehensive JSDoc in a dedicated module.",
            "dependencies": [],
            "details": "Deliverable: src/search/types.ts. Actions: 1) Implement types per spec: Doc = { id: string; title: string; path: string[]; tags: string[]; headings: string[]; symbols: string[]; body: string; mtime: number; size: number }; ParsedQuery = { raw: string; mode: 'files'|'commands'; terms: string[]; phrases: string[]; excludes: string[]; orGroups: string[][]; filters: { tag?: string[]; path?: string[]; in?: string[]; field?: 'headings'|'symbols' }; regex?: { source: string; flags: string } }; MatchSpan = { field: keyof Doc; start: number; end: number }; SearchResult = { id: string; score: number; matchSpans: MatchSpan[] }. 2) Add TSDoc for each type and field describing semantics and constraints (e.g., units for mtime, size; field-specific meaning of MatchSpan). 3) Export supporting utility types if helpful (e.g., QueryMode, Filters) without changing the public shapes. Acceptance: file compiles, exports match the given shapes, and JSDoc renders in editors.\n<info added on 2025-08-21T03:34:33.235Z>\n- Implementation complete in src/search/types.ts: Doc, ParsedQuery, MatchSpan, and SearchResult created per spec.\n- Comprehensive JSDoc added for all types and fields, including units (mtime in ms since epoch, size in bytes) and field-specific MatchSpan semantics.\n- Exported utility types to support consumers without changing public shapes: QueryMode, QueryFilters, SearchableField, FieldWeights, and QueryOptions.\n- Verified compilation and type exports; JSDoc renders correctly in editors. Acceptance criteria satisfied.\n</info added on 2025-08-21T03:34:33.235Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Declare SearchProvider interface and provider selection unions",
            "description": "Define the async SearchProvider interface with Promise-based methods and discriminated unions for provider selection, defaulting to BuiltInProvider.",
            "dependencies": [
              "4.1"
            ],
            "details": "Deliverable: src/search/provider.ts. Actions: 1) Define interface SearchProvider with methods: indexAll(docs: Doc[]): Promise<void>; upsert(doc: Doc): Promise<void>; remove(id: string): Promise<void>; query(q: ParsedQuery, opts?: { limit?: number; signal?: AbortSignal }): Promise<SearchResult[]>; clear(): Promise<void>. 2) Export discriminated union for provider selection, e.g., type ProviderConfig = { kind: 'builtIn'; options?: Record<string, unknown> } | { kind: 'external'; name: string; options?: Record<string, unknown> }; with 'builtIn' as default. 3) Export a factory signature createProvider(config?: ProviderConfig): SearchProvider, with default config { kind: 'builtIn' } and placeholder stubs/types only (no built-in implementation here). 4) Add JSDoc documenting lifecycle, threading/async expectations, and replaceability guarantees. Acceptance: Interface compiles against types from 4.1; union discriminates on kind; default selection is built-in; no implementation-specific coupling.\n<info added on 2025-08-21T03:41:45.237Z>\n- Completed src/search/provider.ts implementation:\n  - Implemented SearchProvider interface with all async methods.\n  - Defined discriminated union ProviderConfig with BuiltInProviderConfig and ExternalProviderConfig; default is { kind: 'builtIn' }.\n  - Implemented createProvider factory using stub built-in/external providers for type safety only.\n  - Added type guards: isBuiltInProvider and isExternalProvider.\n  - Wrote comprehensive JSDoc covering lifecycle, async/abort semantics, threading expectations, and replaceability guarantees.\n  - Verified the module compiles and references Doc, ParsedQuery, and SearchResult from types.ts without implementation coupling.\n</info added on 2025-08-21T03:41:45.237Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement text normalization and tokenization utilities",
            "description": "Provide normalizeText(str, diacritics) and basic tokenization helpers to support providers and query handling.",
            "dependencies": [
              "4.1"
            ],
            "details": "Deliverable: src/search/normalize.ts. Actions: 1) Implement export function normalizeText(str: string, diacritics: boolean): string that lowercases and, when diacritics === false, applies Unicode NFD and strips combining marks (\\p{M}) with a Unicode-aware regex; preserve whitespace. 2) Export helper tokenizeWords(input: string): string[] that uses normalizeText with diacritics setting and splits on non-word boundaries while preserving Unicode letters and numbers. 3) Export maybeNormalizeRegex(rx?: { source: string; flags: string }): RegExp | undefined with try/catch to safely construct RegExp, returning undefined on failure (to aid providers). 4) Add JSDoc and examples for expected behavior (e.g., 'Café' -> 'cafe' when diacritics=false; 'Café' -> 'café' when true). Acceptance: Module compiles; utilities are pure and side-effect free; behavior matches description.\n<info added on 2025-08-21T03:46:11.465Z>\nImplementation complete. Added:\n- normalizeText(str, diacritics) with lowercase + optional NFD diacritic folding using Unicode property escapes; preserves whitespace.\n- tokenizeWords(input) that normalizes then splits with Unicode-aware word matching to support international scripts.\n- maybeNormalizeRegex(rx) that safely constructs a RegExp and returns undefined on failure.\n- JSDoc with examples; resolved a regex literal in comments that broke compilation.\n- Bonus utilities: escapeRegex(str) to safely escape user input; createHighlightRegex(terms, { diacritics }) to build a highlight pattern consistent with normalization; compareStrings(a, b, { diacritics }) for stable, normalized comparisons.\n\nAll functions are pure and side-effect free, and the module compiles successfully.\n</info added on 2025-08-21T03:46:11.465Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add runtime guards and type-level assertions",
            "description": "Introduce type guards for the core types and compile-time assertions to aid narrowing and schema validation.",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "Deliverables: src/search/guards.ts, and minimal type assertion scaffolding. Actions: 1) Implement type guards: isDoc(v: unknown): v is Doc; isParsedQuery(v: unknown): v is ParsedQuery; isMatchSpan(v: unknown): v is MatchSpan; isSearchResult(v: unknown): v is SearchResult. 2) Use structural checks only (presence and types of required fields) and shallow validation for arrays and primitives. 3) Provide helper assertIsParsedQuery(q: unknown): asserts q is ParsedQuery for consumer convenience. 4) Add a small types-only file tests/type-assertions.ts using expectTypeOf (from Vitest) or TS compile-time patterns to assert assignability of typical shapes; wire into test/typecheck by reusing the existing typecheck script. Acceptance: Guards correctly narrow types in sample snippets; compile-time assertions pass.\n<info added on 2025-08-21T03:48:46.229Z>\n- Implemented comprehensive runtime guards in src/search/guards.ts: isDoc, isParsedQuery, isMatchSpan, isSearchResult with structural, shallow validation only.\n- Added helper guards for nested shapes: isQueryMode and isQueryFilters to validate ParsedQuery.mode and ParsedQuery.filters.\n- Added assertion functions that throw TypeError on invalid input: assertIsParsedQuery, assertIsDoc, assertIsSearchResult, assertIsMatchSpan.\n- Added array validators: areValidDocs and areValidSearchResults using the per-item guards.\n- Created tests/type-assertions.ts with Vitest’s expectTypeOf to assert assignability and narrowing for typical shapes; wired into the existing typecheck script.\n- Acceptance update: guards narrow types in example usages; assertion functions throw on invalid input; array validators return correct booleans; compile-time assertions pass; module builds successfully.\n</info added on 2025-08-21T03:48:46.229Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Write contract tests with a mock provider and consumer",
            "description": "Create a mock SearchProvider and contract tests to verify interface compliance, provider swapping, and normalizeText behavior.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.4"
            ],
            "details": "Deliverables: tests/provider.contract.test.ts, tests/normalize.test.ts (Vitest). Actions: 1) Implement MockProvider that satisfies SearchProvider, storing docs in-memory and returning deterministic SearchResult arrays for given ParsedQuery inputs. 2) Write contract tests that: a) exercise indexAll/upsert/remove/clear/query with Promises; b) validate query returns SearchResult[] with required fields and that guards accept them; c) demonstrate swapping providers by injecting MockProvider into a minimal consumer stub (simulating the modal) without changing consumer code. 3) Add tests for normalizeText with/without diacritics and tokenizeWords edge cases (Unicode, punctuation). 4) Include a failing-regex case verifying maybeNormalizeRegex returns undefined and does not throw. Acceptance: All tests pass; types compile; provider swapping requires no consumer changes; normalizeText behaves per spec.\n<info added on 2025-08-21T04:00:56.676Z>\n- Implemented MockProvider class satisfying SearchProvider with in-memory storage and deterministic SearchResult outputs for given ParsedQuery inputs.\n- Added tests/provider.contract.test.ts and tests/normalize.test.ts.\n- Contract tests validate Promise-based indexAll, upsert, remove, clear, and query; ensure SearchResult schema and guards; verify query options handling (filters, regex, modes); and confirm provider swapping by injecting MockProvider into a consumer stub without code changes.\n- Normalization test suite covers diacritic folding, Unicode and punctuation tokenization, regex safety (maybeNormalizeRegex returns undefined on invalid patterns), and edge cases.\n- Fixed createHighlightRegex to support partial matching and corrected combining character expectations; wrapped type assertions within proper Vitest test blocks.\n- Outcome: all 61 tests passing; types compile; provider swapping behavior verified.\n</info added on 2025-08-21T04:00:56.676Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Vault indexer with incremental updates and persistence",
        "description": "Implement vaultIndex to extract Doc fields from TFiles, manage initial indexing, incremental updates on file events, and persist mtime/size cache to skip unchanged files.",
        "details": "Implementation:\n- Module indexer/vaultIndex.ts exports class VaultIndex { indexAll(files:TFile[]): Promise<Doc[]>; upsert(file:TFile): Promise<Doc>; remove(file:TFile): Promise<void> }.\n- Extraction:\n  - title: file.basename\n  - path: tokens from dirname split('/').filter(Boolean)\n  - tags/headings/symbols: use app.metadataCache.getFileCache(file). Collect:\n    - headings: cache.headings?.map(h=>h.heading)\n    - tags: from cache.tags?.map(t=>t.tag.replace('#','')) and cache.frontmatter?.tags (normalize to array)\n    - symbols: links from cache.links?.map(l=>l.link), block refs: parse /\\^[A-Za-z0-9\\-_/]+/ in body, code labels: fenced code block info strings via regex /```(\\S+)/\n  - body: read via app.vault.read(file); lowercased; optionally strip fenced code blocks if settings.general.includeCodeBlocks === false.\n  - mtime, size from file.stat.\n- Persistence: plugin.loadData()/saveData() store map { path: { mtime, size } }. Skip re-tokenizing if unchanged.\n- Events: registerEvent(app.vault.on('create'|'modify'|'delete'|'rename', ...)) and metadataCache.on('changed') to update index and provider.upsert/remove.\n- Lazy body indexing: initially index titles+paths first (fast), then schedule body extraction in chunks using requestIdleCallback or setTimeout batching; on desktop optionally offload to Worker (guard by Platform.isDesktop, feature-flag later).\nPseudo-code:\nasync function indexAll(files){ for f of files { await upsertMeta(f); queueBodyIndex(f); } }\nasync function upsertMeta(f){ const doc = await extractDoc(f, {body:false}); provider.upsert(f, docPartial) }\nfunction queueBodyIndex(f){ enqueue(async()=> provider.upsert(f, await extractDoc(f, {body:true}))) }\n",
        "testStrategy": "Unit:\n- vaultIndex.test.ts: simulate add/modify/delete/rename with fake TFile and metadataCache; assert Doc extraction.\n- Persistence: save mtime cache; modify mtime only when changed.\n- Incremental: modify triggers upsert once; delete triggers provider.remove.\n- Performance: batch queue respects max concurrency; on mobile, ensure chunking to avoid long tasks.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Query parser with filters, phrases, OR/NOT, regex, and commands mode",
        "description": "Implement robust query parsing according to PRD including field prefixes (#, @), tag/path filters, quoted phrases, -exclude, OR groups, fuzzy default, and /regex/ with i flag.",
        "details": "Implementation:\n- Input router: if q.trim().startsWith('>') and settings.commands.enableCommandsPrefix -> return { mode:'commands', raw:q, ... }.\n- Tokenizer:\n  - Extract /\\\"([^\\\"]+)\\\"/ for phrases; remove from string.\n  - Extract regex: \\/((?:\\\\\\/|[^\\/])+?)\\/(i?); validate try new RegExp(source, flags), on error set regex undefined + error message.\n  - Split remaining by whitespace; classify tokens:\n    - '-term' -> excludes\n    - 'OR' -> delimit OR groups (collect between ORs)\n    - 'tag:foo' or '#foo' (as token) -> filters.tag push 'foo'\n    - 'path:proj/x' or 'in:Inbox' -> filters.path or filters.in\n    - '#' alone prefix: set filters.field='headings'\n    - '@' alone prefix: set filters.field='symbols'\n    - otherwise -> terms push token\n- Return ParsedQuery with arrays; preserve raw.\n- Build highlight regex: combine normalized tokens into word-boundary aware regex: new RegExp(`(\\\\b(?:${terms.map(esc).join('|')}))`, 'ig').\nHelper: esc(s) = s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n",
        "testStrategy": "Unit (queryParser.test.ts):\n- Cases: >cmd, #heading-only, @symbols, tag:foo and #foo, path:proj/x, in:Inbox, \"exact phrase\", /regex/i valid and invalid, OR groups, -exclude, empty query.\n- Ensure ParsedQuery.mode flips between files and commands; invalid regex flagged and ignored.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Scoring model with fuzzy/prefix and recency bonus",
        "description": "Implement fuzzy and prefix scoring per field, configurable weights, diacritic folding, and recency bonus up to 0.5.",
        "details": "Implementation:\n- normalizeText(str, diacritics) as in task 4; tokenization by /[\\p{L}\\p{N}_-]+/u.\n- Fuzzy metric: use optimized token-level Levenshtein prefix-aware scoring:\n  scoreToken(query, text){\n    if (text.startsWith(query)) return 1;\n    const dist = damerauLevenshtein(query, text); // cap at 2 for perf\n    return Math.max(0, 1 - dist / Math.max(query.length, text.length));\n  }\n- Field fuzzy(fieldValue, terms): compute max score across tokens per term; aggregate as average across terms.\n- Phrase match: boost by +0.25 per phrase exact match occurrence in title/body.\n- recencyBonus(mtime): now=Date.now(); ageDays=(now-mtime)/86400000; return clamp(0.5 * Math.exp(-ageDays/30), 0, 0.5).\n- Overall:\n  total = w_title*f(title) + w_headings*f(headings) + w_path*f(path) + w_tags*f(tags) + w_symbols*f(symbols) + w_body*f(body) + recencyBonus.\n- Respect excludes by subtracting large penalty or removing candidate earlier.\n- Export scorer(configFromSettings).\nPseudo-code:\nfunction scoreDoc(doc, pq, weights){ let s=0; s += weights.title*f(doc.title); ...; s += recencyBonus(doc.mtime); return s }\n",
        "testStrategy": "Unit (scorer.test.ts):\n- Verify weights affect ordering deterministically.\n- Recency: newer docs get <=0.5 bonus; older decay.\n- Prefix matches outrank non-prefix fuzzy for same field.\n- Diacritics folding: 'cafe' matches 'café'.\n- Excludes remove hits containing the term.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Built-in search provider with inverted index and regex post-filter",
        "description": "Implement BuiltInProvider using a MiniSearch-style inverted index, supporting indexAll, upsert, remove, and query with filters, fuzzy/prefix, weights, and regex applied to top-K candidates.",
        "details": "Implementation:\n- Data structures:\n  - term -> posting list of docIds with per-field term frequency and token positions.\n  - doc store: Map<id, Doc>.\n- Indexing:\n  - For each field (title, path, headings, tags, symbols, body), tokenize normalized values and store positions.\n  - Keep body length cap (e.g., 2MB) to skip huge files.\n- Query:\n  - If empty ParsedQuery and no terms/filters -> return recent notes by mtime desc.\n  - Build candidate set by union across terms with AND semantics enforced by intersection unless pq.orGroups present.\n  - Apply filters: tags, path prefixes, 'in' folder exact or prefix.\n  - For field filter (# or @), restrict scoring to that field.\n  - Score using scorer from task 7; maintain top N by heap up to settings.general.maxResults.\n  - Regex: if pq.regex present, take top K (settings.search.regexCandidateK, default 300), apply RegExp to original body/title; discard non-matching.\n  - Return SearchResult[] with matchSpans for highlighting: for each term found, compute approximate positions from index tokens; for regex, compute match indices.\n- Portability: pure TS, no native binaries; consider vendoring minimal code for Damerau-Levenshtein or implement lightweight version.\nPseudo-code:\nclass BuiltInProvider implements SearchProvider { async indexAll(files){...}; async upsert(file, content){...}; async remove(file){...}; async query(pq, limit){ if (isEmpty(pq)) return recent(); const candidates = gatherCandidates(pq); const scored = scoreAll(candidates); const filtered = applyRegexIfAny(scored); return topN(filtered, limit); } }\n",
        "testStrategy": "Unit (builtInProvider.test.ts):\n- Index docs and ensure deterministic top-k for known queries.\n- Filters: tag, path, in-folder, field-only (#/@) behave as expected.\n- Regex: only applied to top-K; invalid regex ignored.\n- Update: upsert modifies index; remove prunes postings.\n- Empty query returns recent by mtime desc.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Modal UI with results, create/open semantics, commands mode, and preview",
        "description": "Build the nvALT-like modal with one input, results list (with inline snippet and right-side mtime/path), and bottom preview with multi-fragment highlights and keyboard navigation.",
        "details": "Implementation:\n- modal.tsx: Custom modal based on SuggestModal or own Modal with React-like rendering (or vanilla DOM). Structure: top input, middle results (listbox role), bottom preview pane (fixed height).\n- Results item: left: Title — inline snippet (~120 chars) with <mark>; right: modified relative date + small path.\n- Inline snippet: preview/snippet.ts to select best-first fragment near top hit; highlight.ts to wrap with <mark> using a single combined regex.\n- Preview pane: generate N fragments (default 3, up to 5), merge overlapping, provide ◀ ▶ buttons with aria-label and keyboard Alt←/→ cycling; header line shows file title and optional chips tags/path.\n- Commands mode: if input starts with '>' switch to commands; fetch commands via app.commands.listCommands(); fuzzy filter by name/id; Enter executes via app.commands.executeCommandById(id); mod+Enter tries open in split when command supports target leaf (if not, ignore).\n- Create/Open:\n  - Enter: if matches exist -> open selected; if zero matches -> create Query.md.\n  - Shift+Enter: force-create using current input.\n  - Path support: parse folder/Note; ensure folder exists via app.vault.createFolder before create; on collision open existing file.\n  - Open: use workspace.getLeaf(isSplit) and leaf.openFile(file).\n- Keyboard:\n  - Up/Down and J/K (Cmd or Ctrl by platform) move selection.\n  - Tab focuses preview; Esc returns to input; Esc again closes.\n  - mod+Enter opens in split.\n- Empty query: show recent notes by mtime desc (from provider or vault index).\n- Accessibility: listbox/option roles, aria-selected, focus ring, ensure <mark> contrast via CSS var.\n- Virtualization (optional): if results > 200, render windowed rows based on scroll position.\nPseudo-code:\nclass NvModal extends Modal { onOpen(){ /* build DOM, bind input */ } onInput(q){ const pq=parseQuery(q); if (pq.mode==='commands') showCommands(); else showFiles(provider.query(pq, maxResults)); } onEnter(){ /* create/open semantics */ } renderPreview(file, fragments){ /* bottom pane */ } }\n",
        "testStrategy": "Integration (modal.behavior.test.ts with JSDOM):\n- Typing query updates list within 200ms budget (mock timers).\n- Enter opens existing; Shift+Enter creates even with matches; zero-result shows Create \"{Query}\" row.\n- Commands mode: '>' shows commands; Enter executes stubbed command; mod+Enter attempts split open.\n- Keyboard: J/K or Arrow keys navigate; Tab/Esc focus behavior; Alt←/→ cycles fragments.\n- Accessibility: roles, aria-selected toggles; chevron buttons have aria-labels.\n- Edge cases: invalid regex shows inline error chip; create path collision opens existing.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Test suites (unit and integration) and performance validation",
        "description": "Implement TDD-first automated tests for parser, scorer, snippet/highlight, vault indexer, built-in provider, and modal behaviors; add basic performance harness and acceptance checks.",
        "details": "Implementation:\n- Vitest config: environment jsdom for integration; node for unit.\n- Unit tests:\n  - queryParser.test.ts: >cmd, #heading, @symbol, tag:foo, path:x, \"phrase\", /regex/i, OR, -exclude, empty query.\n  - scorer.test.ts: field weights & recency; diacritics.\n  - snippet.test.ts: fragment selection, ellipses, overlap merge, HTML escape, <mark> highlights, fragment length bounds (60–240).\n  - vaultIndex.test.ts: add/modify/delete/rename; headings/tags/symbols extraction; includeCodeBlocks toggle.\n  - builtInProvider.test.ts: indexAll, upsert, remove, query with deterministic results; regex candidate cap K.\n- Integration (JSDOM): modal.behavior.test.ts covering open/create, commands execution, navigation, focus behavior, fragment cycling, zero-result state.\n- Performance checks:\n  - Seed 10k synthetic docs; ensure query pipeline returns first results <200ms on desktop env by mocking timers and measuring code path; ensure regex applied to top-K only.\n- CI: gate on tests; collect coverage thresholds ≥80% for core logic.\n",
        "testStrategy": "Execution:\n- Run vitest watch in development; ensure failures drive implementation (TDD).\n- Include snapshot tests for DOM structure of modal rows and preview.\n- Simulate mobile by throttling timers and verifying no long blocking tasks (>50ms chunks).\n- Acceptance criteria mapping: write tests verifying all 8 acceptance bullets in PRD.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-21T01:58:07.396Z",
      "updated": "2025-08-21T04:01:14.254Z",
      "description": "Tasks for master context"
    }
  }
}