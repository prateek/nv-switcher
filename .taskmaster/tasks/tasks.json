{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project scaffolding, build, and CI setup",
        "description": "Initialize Obsidian plugin project with TypeScript, tsup bundling to a single main.js, testing (Vitest + JSDOM), linting, and GitHub Actions CI for typecheck, test, build, and release zip.",
        "details": "Implementation:\n- Files: manifest.json, package.json, tsconfig.json, tsup.config.ts, .eslintrc, .prettierrc, vitest.config.ts, src/plugin.ts, src/styles.css, README.md, LICENSE (MIT).\n- manifest.json: { id: \"obsidian-nv-switcher\", name: \"nv-switcher\", version: \"1.0.0\", minAppVersion: \"1.5.0\", author, main: \"main.js\", description }.\n- package.json devDeps: obsidian (types), typescript, tsup, vitest, @vitest/ui, jsdom, eslint, @typescript-eslint/*, esbuild.\n- tsup: entry src/plugin.ts, format iife, globalName plugin, minify, sourcemap, target es2020, define process.env.NODE_ENV.\n- plugin.ts exports default class NvSwitcherPlugin extends Plugin { async onload() { ... } async onunload() { ... } }.\n- GitHub Actions: workflow to install deps, build, run tests, upload artifact (main.js, manifest.json, styles.css) as release asset on tag.\n- CSS: define --nv-switcher-highlight-color var fallback to theme.\nPseudo-code:\nclass NvSwitcherPlugin extends Plugin {\n  settings: Settings;\n  async onload() {\n    await this.loadSettings();\n    this.addSettingTab(new NvSwitcherSettingsTab(this.app, this));\n    this.registerCommands();\n  }\n  async loadSettings(){ this.settings = Object.assign(DEFAULT_SETTINGS, await this.loadData()); }\n  async saveSettings(){ await this.saveData(this.settings); }\n}\n",
        "testStrategy": "Validation:\n- Build: tsup builds single main.js; verify manifest fields.\n- CI: PR triggers typecheck, lint, tests; tag v1.0.0 creates release artifact.\n- Unit: sanity tests load plugin class with mock app.\n- Manual: load plugin in Obsidian sandbox vault to ensure it appears and loads without errors.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Settings schema and SettingsTab UI",
        "description": "Implement comprehensive settings model and SettingsTab UI per PRD (.taskmaster/docs/prd.md), covering General, Search, Preview, Commands mode, and Hotkeys/Keyboard customization with reactive storage, validation, and migrations.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "details": "Source of truth: Use .taskmaster/docs/prd.md (section 8: Settings; section 3: Keyboard; plus related snippets/preview constraints from other sections) for field names, defaults, ranges, and behavior. Where PRD is silent, retain existing defaults.\n\nImplementation:\n- Define Settings interface and DEFAULT_SETTINGS with schemaVersion and complete field mapping as per PRD:\n  schemaVersion: number (start at 1). Used for migrations.\n  general:\n    - openHotkey: string (keyboard chord; default as specified in PRD Keyboard section; fallback Mod+K or ⌘N if not specified).\n    - createLocation: 'root' | 'same' | 'fixed'.\n    - fixedFolder: string (validated; create if missing when selected).\n    - includeCodeBlocks: boolean (default false).\n    - maxResults: number (default 100; min/max bounds per PRD).\n    - debounceMs: number (search input debounce; per PRD, default e.g., 80–150ms range; clamp to [20, 500]).\n    - minQueryLength: number (default 1; clamp to [0, 10]).\n  search:\n    - backend: 'built-in' | 'auto' | 'omni' (per PRD terminology; wire to providers).\n    - weights: { title, headings, path, tags, symbols, body, recency } numbers mapping directly to scorer weights.\n    - diacritics: boolean (default true; fold accents if true).\n    - regexCandidateK: number (default 300; clamp to reasonable bounds, e.g., [50, 2000]).\n    - recencyHalfLifeDays: number (maps to decay used by scorer; PRD value; clamp to [1, 365]).\n    - excludeFolders: string[] (folder paths or glob-like patterns; normalized; used by indexer/search to ignore).\n  preview:\n    - inlineSnippet: boolean (default true).\n    - fragmentLength: number (default 120; clamp to [60, 240] as per PRD/tests).\n    - maxFragments: number (default 3; clamp to [1, 5]).\n    - showFrontmatter: boolean (default false).\n    - showTags: boolean (default true).\n    - showPath: boolean (default true).\n    - highlightCssVar: string (default \"--nv-switcher-highlight-color\").\n    - highlightColor: string (CSS color value; default per PRD; if set, write to documentElement.style for highlightCssVar).\n  commands:\n    - enableCommandsPrefix: boolean (default true; gates \">\" router per PRD).\n    - commandsPrefixChar: string (default '>' per PRD; single visible char; validated non-empty).\n    - showCommandIds: boolean (default false).\n    - openInSplitModifier: 'mod' | 'alt' | 'shift' | 'ctrl' (default per PRD; used to interpret modified open action).\n  keyboard:\n    - chordSeparator: string (default '+', from PRD Keybinding grammar).\n    - platformMetaKey: 'mod' | 'cmdCtrl' (internal helper reflecting PRD guidance; affects display).\n  hotkeys: Record<string, string[]> mapping modal actions to arrays of keyboard chords (strings). Actions include at minimum: moveUp, moveDown, open, forceCreate, openInSplit, focusPreview, cycleLeft, cycleRight, close, toggleCommandsMode, clearQuery, acceptSelection. Defaults must match PRD section 3 per platform (Cmd on macOS, Ctrl on Windows/Linux). Ensure chords follow PRD grammar (e.g., Mod+Enter, Shift+Tab, Ctrl+J, etc.).\n\n- Settings storage:\n  - Reactive load/save on plugin init and SettingsTab changes; debounce saves using requestIdleCallback or setTimeout (~150ms) to avoid churn.\n  - Add migrateSettings(prev: any): Settings that upgrades based on schemaVersion (e.g., v0 -> v1 adds debounceMs, minQueryLength, recencyHalfLifeDays, commandsPrefixChar, highlightColor, keyboard, excludeFolders). Never mutate previous object in-place; return a new Settings with defaults for new fields.\n\n- Validation:\n  - fixedFolder: normalize path; verify or create when createLocation === 'fixed'. Show inline error in SettingsTab if invalid; disable save/selection when invalid.\n  - Numeric ranges: clamp values to PRD-defined ranges; show helper text with ranges under sliders.\n  - commandsPrefixChar: require single non-whitespace glyph; cannot conflict with hotkey chords typing (per PRD notes). If changed, reflect in input router behavior.\n  - hotkeys: parse/normalize chords (case-insensitive keys, normalized modifiers order per PRD). Detect conflicts between actions; render warnings and allow override/reset.\n  - excludeFolders: validate entries; trim; ignore duplicates.\n\n- SettingsTab UI (PluginSettingTab):\n  - Render sections: General, Search, Preview, Commands, Keyboard & Hotkeys (grouped as per PRD). Use toggles, text inputs, dropdowns, sliders with labels/tooltips sourced from PRD copy.\n  - Bind controls to plugin.settings; onChange -> validate -> set -> debounced save.\n  - Hotkeys editor: show list of actions with current chords; add/remove/reset per PRD; indicate platform defaults; show conflict badges.\n  - Weights sliders map to numeric values and persist; provide reset-to-PRD-defaults button per section.\n  - Commands: input for prefix char; toggle enable; toggle showCommandIds; dropdown for split modifier.\n  - Preview: controls for fragmentLength, maxFragments, highlightCssVar, highlightColor; on change, apply CSS var to documentElement; on unload, remove previously set var.\n\n- Expose getters/helpers:\n  - toScorerConfig(): translates settings.search.weights, diacritics, recencyHalfLifeDays into scorer module configuration.\n  - isCommandsQuery(input: string): checks prefix based on enableCommandsPrefix and commandsPrefixChar.\n  - getNormalizedHotkeys(): returns platform-specific chords expanded and normalized for use in modal.\n\n- CSS var application:\n  - On load and whenever preview.highlightColor or preview.highlightCssVar changes, set document.documentElement.style.setProperty(highlightCssVar, highlightColor). On unload/reset, removeProperty.\n\nPseudo-code:\ninterface Settings { schemaVersion: number; general: {...}; search: {...}; preview: {...}; commands: {...}; keyboard: {...}; hotkeys: Record<string, string[]> }\nfunction migrateSettings(prev:any): Settings { /* add missing fields with PRD defaults; bump schemaVersion */ }\nclass NvSwitcherSettingsTab extends PluginSettingTab { display(){ /* build UI per PRD; bind, validate, debounce save */ } }\n",
        "testStrategy": "Unit:\n- Load/save roundtrip with DEFAULT_SETTINGS including new fields (schemaVersion, debounceMs, minQueryLength, recencyHalfLifeDays, commandsPrefixChar, highlightColor, excludeFolders, keyboard). Unknown fields preserved; missing fields filled with defaults via migrateSettings.\n- Migration: simulate old settings (v0) and ensure migrateSettings returns v1 with correct defaults; no data loss for existing fields.\n- Validation: fixedFolder path normalization/creation; numeric clamping for fragmentLength [60,240], maxFragments [1,5], regexCandidateK bounds, debounceMs bounds; commandsPrefixChar single-glyph requirement; excludeFolders sanitized.\n- Keyboard/Hotkeys:\n  - Normalize \"mod\" to Cmd/Ctrl per platform; parse chords order; detect conflicts; ensure defaults match PRD section 3.\n  - openInSplitModifier behavior: verify interpretation in key handling helper.\n- Commands router: when enableCommandsPrefix=true and commandsPrefixChar='>', input starting with '>' routes to commands; when disabled or char changed, router honors setting.\n- Weights: ensure sliders map to numeric values and persist within ranges; toScorerConfig() produces expected shape for scorer module.\n- CSS: setting highlightCssVar/highlightColor writes to documentElement.style and removes on unload.\n\nUI (JSDOM):\n- Render SettingsTab and simulate user interactions: toggling diacritics/includeCodeBlocks; editing commandsPrefixChar; adjusting sliders; adding/removing hotkey chords; adding excludeFolders. Assert plugin.settings reflects changes and debounced saves occur (spy on saveSettings).\n- Snapshot critical UI groups (General, Search/weights, Preview, Commands, Hotkeys) for structure and labels per PRD.\n",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Settings types, DEFAULT_SETTINGS, and schemaVersion per PRD",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement migrateSettings(prev) to upgrade legacy settings to v1",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build SettingsTab UI with sections and controls mapped to PRD fields",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement validation for paths, numeric ranges, prefix char, and hotkey conflicts",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Apply highlight CSS variable on load/changes and clean up on unload",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Expose helpers: toScorerConfig, isCommandsQuery, getNormalizedHotkeys",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Write unit and JSDOM tests for settings, UI bindings, keyboard, and migrations",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Commands registration and Hotkey handling",
        "description": "Register plugin commands and wire default hotkeys; centralize in-modal hotkey mapping with customizable bindings from Settings. Update the existing open command to use the settings-defined hotkey, add a toggle-inline-snippet command, implement HotkeyManager for in-modal actions, and support open-in-split via workspace.getLeaf(true).",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "details": "Implementation plan (building on existing settings and hotkeys config):\n- Commands registration:\n  - Update existing 'open-nv-switcher' command to derive its default hotkey from settings (e.g., settings.general.openHotkey such as 'Mod-N'). On load, parse the chord string into Obsidian Command hotkeys format. Provide a sensible fallback (e.g., 'Mod-N') when unset.\n  - Add 'toggle-inline-snippet' command (id: nv-switcher:toggle-inline-snippet) with no default hotkey. It toggles settings.preview.inlineSnippet and persists via saveSettings().\n  - Pseudocode:\n    registerCommands(){\n      const hotkey = this.settings.general.openHotkey || 'Mod-N';\n      this.addCommand({\n        id: 'open-nv-switcher',\n        name: 'Open nv-switcher',\n        hotkeys: parseAccelToObsidianHotkeys(hotkey),\n        callback: () => new NvModal(this.app, this).open()\n      });\n      this.addCommand({\n        id: 'toggle-inline-snippet',\n        name: 'Toggle inline snippet',\n        callback: async () => { this.settings.preview.inlineSnippet = !this.settings.preview.inlineSnippet; await this.saveSettings(); }\n      });\n    }\n- HotkeyManager for in-modal actions:\n  - Create a HotkeyManager that reads plugin.settings.hotkeys and matches KeyboardEvent for modal-scoped actions (e.g., navigateUp: 'K', navigateDown: 'J', nextItem: 'Tab', close: 'Escape', back/forward: 'Alt-ArrowLeft/Right', openInSplit: 'Mod-Enter', open: 'Enter', create: 'Shift-Enter').\n  - Cross-platform: 'Mod' maps to Meta on macOS and Ctrl elsewhere. Use Obsidian's Keymap.isModifier and Platform.isMacOS to normalize modifiers. Support parsing chords like 'Mod-Enter', 'Shift-Enter', 'Alt-ArrowLeft', single keys ('J', 'K'), and standard arrows.\n  - Expose helpers like is(action, evt), matchHotkey(evt, accel: string), and parseAccelToObsidianHotkeys(accel: string) to convert settings strings into Command hotkeys array.\n- Modal integration:\n  - In NvModal's keydown handler, delegate to HotkeyManager to resolve actions. Ensure openInSplit is triggered by either the explicit action mapping or by detecting 'Mod-Enter'.\n  - Open in split implementation: when openInSplit, call this.app.workspace.getLeaf(true) and open the file there; otherwise open in the current leaf. Close the modal after opening.\n- Settings changes:\n  - The plugin already has a comprehensive settings model (including hotkeys). Build the HotkeyManager to read from the current settings instance so new modal instances pick up changes immediately. For the open command's hotkey, refresh the command registration on settings change if feasible; otherwise document that changing the open-hotkey requires reloading the plugin to update the default command binding (users can still override via Obsidian Hotkeys UI).\n- Utility:\n  - Implement parseAccelToObsidianHotkeys('Mod-N' | 'Alt-ArrowLeft' | 'Shift-Enter'...) -> Obsidian Command.hotkeys format.\n  - Implement matchHotkey(evt, 'Mod-Enter'...) -> boolean using KeyboardEvent fields and Keymap/Platform helpers.",
        "testStrategy": "Integration (JSDOM) and unit tests:\n- Command hotkey from settings:\n  - With settings.general.openHotkey = 'Mod-N', ensure addCommand receives hotkeys parsed to [{ modifiers:['Mod'], key:'n' }]. Adjust setting and verify parser updates output. If command re-registration on settings change is implemented, verify hotkey array updates; otherwise verify documentation note.\n- Toggle inline snippet command:\n  - Execute 'nv-switcher:toggle-inline-snippet' command and assert settings.preview.inlineSnippet toggles and saveSettings called.\n- HotkeyManager unit tests:\n  - matchHotkey for: 'Mod-Enter' (Cmd on macOS, Ctrl elsewhere), 'Shift-Enter', 'Alt-ArrowLeft/Right', 'J', 'K', 'Tab', 'Escape'. Verify modifiers via simulated KeyboardEvent init.\n  - Cross-platform behavior: Platform.isMacOS true/false toggles modifier expectations.\n- Modal integration (JSDOM):\n  - Press settings-mapped open hotkey (dispatch KeyboardEvent) to open modal instance (callback invoked).\n  - In modal: simulate mapped keys to navigate (J/K), tab selection, escape to close, Enter to open in current leaf.\n  - Open-in-split: simulate 'Mod-Enter' or mapped openInSplit action; assert app.workspace.getLeaf(true) is called and file opens in new leaf.\n  - Rebinding in settings (hotkeys map) and constructing a new modal picks up updated bindings at runtime.",
        "subtasks": [
          {
            "id": 1,
            "title": "Wire 'open-nv-switcher' command to settings-based hotkey",
            "description": "Use settings.general.openHotkey to derive the command's default hotkeys via parseAccelToObsidianHotkeys with fallback to 'Mod-N'. Register on load; optionally re-register on settings change.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Add 'toggle-inline-snippet' command",
            "description": "Register nv-switcher:toggle-inline-snippet without a default hotkey; toggle settings.preview.inlineSnippet and persist via saveSettings().",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement HotkeyManager for in-modal actions",
            "description": "Create a class that parses accelerator strings from settings.hotkeys, normalizes modifiers (Mod/Ctrl/Cmd), and matches KeyboardEvent using Keymap.isModifier and Platform.isMacOS.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Integrate HotkeyManager into NvModal",
            "description": "Route keydown events to HotkeyManager to handle navigateUp/down (J/K), Tab, Escape, Alt-ArrowLeft/Right, Enter, Shift-Enter, and Mod-Enter (openInSplit).",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement open-in-split behavior",
            "description": "When openInSplit is triggered, use app.workspace.getLeaf(true) to open the selected file in a new split; otherwise open in the current leaf.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add unit/integration tests for commands and hotkeys",
            "description": "Test command hotkey parsing from settings, toggle-inline-snippet behavior, HotkeyManager matching (including cross-platform Mod), modal key handling, and open-in-split leaf selection.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Search types and provider interface",
        "description": "Define types for Doc, ParsedQuery, SearchResult, and the SearchProvider interface to enable provider swapping.",
        "details": "Implementation:\n- Types:\n  type Doc = { id: string; title: string; path: string[]; tags: string[]; headings: string[]; symbols: string[]; body: string; mtime: number; size: number };\n  type ParsedQuery = { raw: string; mode: 'files'|'commands'; terms: string[]; phrases: string[]; excludes: string[]; orGroups: string[][]; filters: { tag?: string[]; path?: string[]; in?: string[]; field?: 'headings'|'symbols' }; regex?: { source:string; flags:string } };\n  type MatchSpan = { field: keyof Doc, start: number, end: number };\n  type SearchResult = { id: string; score: number; matchSpans: MatchSpan[] };\n- SearchProvider interface as in PRD with Promise signatures.\n- Export discriminated unions for provider selection (BuiltInProvider default).\n- Utilities: normalizeText(str, diacritics:boolean): lowercases + NFD strip if enabled.\n",
        "testStrategy": "Unit:\n- Type-level tests via tsd or compile checks.\n- Runtime guards: narrow ParsedQuery fields; ensure SearchResult schema contains required fields.\n- Contract tests: mock provider implementing interface, consumed by modal without knowledge of implementation.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define core search domain types",
            "description": "Create and export TypeScript types for Doc, ParsedQuery, MatchSpan, and SearchResult with comprehensive JSDoc in a dedicated module.",
            "dependencies": [],
            "details": "Deliverable: src/search/types.ts. Actions: 1) Implement types per spec: Doc = { id: string; title: string; path: string[]; tags: string[]; headings: string[]; symbols: string[]; body: string; mtime: number; size: number }; ParsedQuery = { raw: string; mode: 'files'|'commands'; terms: string[]; phrases: string[]; excludes: string[]; orGroups: string[][]; filters: { tag?: string[]; path?: string[]; in?: string[]; field?: 'headings'|'symbols' }; regex?: { source: string; flags: string } }; MatchSpan = { field: keyof Doc; start: number; end: number }; SearchResult = { id: string; score: number; matchSpans: MatchSpan[] }. 2) Add TSDoc for each type and field describing semantics and constraints (e.g., units for mtime, size; field-specific meaning of MatchSpan). 3) Export supporting utility types if helpful (e.g., QueryMode, Filters) without changing the public shapes. Acceptance: file compiles, exports match the given shapes, and JSDoc renders in editors.\n<info added on 2025-08-21T03:34:33.235Z>\n- Implementation complete in src/search/types.ts: Doc, ParsedQuery, MatchSpan, and SearchResult created per spec.\n- Comprehensive JSDoc added for all types and fields, including units (mtime in ms since epoch, size in bytes) and field-specific MatchSpan semantics.\n- Exported utility types to support consumers without changing public shapes: QueryMode, QueryFilters, SearchableField, FieldWeights, and QueryOptions.\n- Verified compilation and type exports; JSDoc renders correctly in editors. Acceptance criteria satisfied.\n</info added on 2025-08-21T03:34:33.235Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Declare SearchProvider interface and provider selection unions",
            "description": "Define the async SearchProvider interface with Promise-based methods and discriminated unions for provider selection, defaulting to BuiltInProvider.",
            "dependencies": [
              "4.1"
            ],
            "details": "Deliverable: src/search/provider.ts. Actions: 1) Define interface SearchProvider with methods: indexAll(docs: Doc[]): Promise<void>; upsert(doc: Doc): Promise<void>; remove(id: string): Promise<void>; query(q: ParsedQuery, opts?: { limit?: number; signal?: AbortSignal }): Promise<SearchResult[]>; clear(): Promise<void>. 2) Export discriminated union for provider selection, e.g., type ProviderConfig = { kind: 'builtIn'; options?: Record<string, unknown> } | { kind: 'external'; name: string; options?: Record<string, unknown> }; with 'builtIn' as default. 3) Export a factory signature createProvider(config?: ProviderConfig): SearchProvider, with default config { kind: 'builtIn' } and placeholder stubs/types only (no built-in implementation here). 4) Add JSDoc documenting lifecycle, threading/async expectations, and replaceability guarantees. Acceptance: Interface compiles against types from 4.1; union discriminates on kind; default selection is built-in; no implementation-specific coupling.\n<info added on 2025-08-21T03:41:45.237Z>\n- Completed src/search/provider.ts implementation:\n  - Implemented SearchProvider interface with all async methods.\n  - Defined discriminated union ProviderConfig with BuiltInProviderConfig and ExternalProviderConfig; default is { kind: 'builtIn' }.\n  - Implemented createProvider factory using stub built-in/external providers for type safety only.\n  - Added type guards: isBuiltInProvider and isExternalProvider.\n  - Wrote comprehensive JSDoc covering lifecycle, async/abort semantics, threading expectations, and replaceability guarantees.\n  - Verified the module compiles and references Doc, ParsedQuery, and SearchResult from types.ts without implementation coupling.\n</info added on 2025-08-21T03:41:45.237Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement text normalization and tokenization utilities",
            "description": "Provide normalizeText(str, diacritics) and basic tokenization helpers to support providers and query handling.",
            "dependencies": [
              "4.1"
            ],
            "details": "Deliverable: src/search/normalize.ts. Actions: 1) Implement export function normalizeText(str: string, diacritics: boolean): string that lowercases and, when diacritics === false, applies Unicode NFD and strips combining marks (\\p{M}) with a Unicode-aware regex; preserve whitespace. 2) Export helper tokenizeWords(input: string): string[] that uses normalizeText with diacritics setting and splits on non-word boundaries while preserving Unicode letters and numbers. 3) Export maybeNormalizeRegex(rx?: { source: string; flags: string }): RegExp | undefined with try/catch to safely construct RegExp, returning undefined on failure (to aid providers). 4) Add JSDoc and examples for expected behavior (e.g., 'Café' -> 'cafe' when diacritics=false; 'Café' -> 'café' when true). Acceptance: Module compiles; utilities are pure and side-effect free; behavior matches description.\n<info added on 2025-08-21T03:46:11.465Z>\nImplementation complete. Added:\n- normalizeText(str, diacritics) with lowercase + optional NFD diacritic folding using Unicode property escapes; preserves whitespace.\n- tokenizeWords(input) that normalizes then splits with Unicode-aware word matching to support international scripts.\n- maybeNormalizeRegex(rx) that safely constructs a RegExp and returns undefined on failure.\n- JSDoc with examples; resolved a regex literal in comments that broke compilation.\n- Bonus utilities: escapeRegex(str) to safely escape user input; createHighlightRegex(terms, { diacritics }) to build a highlight pattern consistent with normalization; compareStrings(a, b, { diacritics }) for stable, normalized comparisons.\n\nAll functions are pure and side-effect free, and the module compiles successfully.\n</info added on 2025-08-21T03:46:11.465Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add runtime guards and type-level assertions",
            "description": "Introduce type guards for the core types and compile-time assertions to aid narrowing and schema validation.",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "Deliverables: src/search/guards.ts, and minimal type assertion scaffolding. Actions: 1) Implement type guards: isDoc(v: unknown): v is Doc; isParsedQuery(v: unknown): v is ParsedQuery; isMatchSpan(v: unknown): v is MatchSpan; isSearchResult(v: unknown): v is SearchResult. 2) Use structural checks only (presence and types of required fields) and shallow validation for arrays and primitives. 3) Provide helper assertIsParsedQuery(q: unknown): asserts q is ParsedQuery for consumer convenience. 4) Add a small types-only file tests/type-assertions.ts using expectTypeOf (from Vitest) or TS compile-time patterns to assert assignability of typical shapes; wire into test/typecheck by reusing the existing typecheck script. Acceptance: Guards correctly narrow types in sample snippets; compile-time assertions pass.\n<info added on 2025-08-21T03:48:46.229Z>\n- Implemented comprehensive runtime guards in src/search/guards.ts: isDoc, isParsedQuery, isMatchSpan, isSearchResult with structural, shallow validation only.\n- Added helper guards for nested shapes: isQueryMode and isQueryFilters to validate ParsedQuery.mode and ParsedQuery.filters.\n- Added assertion functions that throw TypeError on invalid input: assertIsParsedQuery, assertIsDoc, assertIsSearchResult, assertIsMatchSpan.\n- Added array validators: areValidDocs and areValidSearchResults using the per-item guards.\n- Created tests/type-assertions.ts with Vitest’s expectTypeOf to assert assignability and narrowing for typical shapes; wired into the existing typecheck script.\n- Acceptance update: guards narrow types in example usages; assertion functions throw on invalid input; array validators return correct booleans; compile-time assertions pass; module builds successfully.\n</info added on 2025-08-21T03:48:46.229Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Write contract tests with a mock provider and consumer",
            "description": "Create a mock SearchProvider and contract tests to verify interface compliance, provider swapping, and normalizeText behavior.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.4"
            ],
            "details": "Deliverables: tests/provider.contract.test.ts, tests/normalize.test.ts (Vitest). Actions: 1) Implement MockProvider that satisfies SearchProvider, storing docs in-memory and returning deterministic SearchResult arrays for given ParsedQuery inputs. 2) Write contract tests that: a) exercise indexAll/upsert/remove/clear/query with Promises; b) validate query returns SearchResult[] with required fields and that guards accept them; c) demonstrate swapping providers by injecting MockProvider into a minimal consumer stub (simulating the modal) without changing consumer code. 3) Add tests for normalizeText with/without diacritics and tokenizeWords edge cases (Unicode, punctuation). 4) Include a failing-regex case verifying maybeNormalizeRegex returns undefined and does not throw. Acceptance: All tests pass; types compile; provider swapping requires no consumer changes; normalizeText behaves per spec.\n<info added on 2025-08-21T04:00:56.676Z>\n- Implemented MockProvider class satisfying SearchProvider with in-memory storage and deterministic SearchResult outputs for given ParsedQuery inputs.\n- Added tests/provider.contract.test.ts and tests/normalize.test.ts.\n- Contract tests validate Promise-based indexAll, upsert, remove, clear, and query; ensure SearchResult schema and guards; verify query options handling (filters, regex, modes); and confirm provider swapping by injecting MockProvider into a consumer stub without code changes.\n- Normalization test suite covers diacritic folding, Unicode and punctuation tokenization, regex safety (maybeNormalizeRegex returns undefined on invalid patterns), and edge cases.\n- Fixed createHighlightRegex to support partial matching and corrected combining character expectations; wrapped type assertions within proper Vitest test blocks.\n- Outcome: all 61 tests passing; types compile; provider swapping behavior verified.\n</info added on 2025-08-21T04:00:56.676Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Vault indexer with incremental updates and persistence",
        "description": "Implement vaultIndex to extract Doc fields from TFiles, manage initial indexing, incremental updates on file events, and persist mtime/size cache to skip unchanged files. Implementation completed with event handling, throttling, lazy body indexing, and persistent change detection.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "details": "Implemented a comprehensive vault indexing system under src/indexer/ with the following components:\n\nCore Components:\n- VaultIndex class (src/indexer/vault-index.ts):\n  - Methods:\n    - indexAll(files: TFile[]): Promise<Doc[]> — bulk initial indexing; performs fast metadata indexing first and queues body extraction lazily in batches\n    - upsert(file: TFile): Promise<Doc> — upserts a single file immediately\n    - upsertIfChanged(file: TFile): Promise<Doc | null> — skips re-tokenizing when mtime/size unchanged via cache\n    - remove(file: TFile): Promise<void> — removes a file from the index\n    - rename(oldFile: TFile, newFile: TFile): Promise<void> — handles path/title changes without full reindex where possible\n  - Document extraction from TFiles with full metadata parsing and settings-aware content processing\n\n- VaultEventHandler class (src/indexer/event-handler.ts):\n  - Subscribes to vault events (create, modify, delete, rename) and metadataCache 'changed'\n  - Throttles rapid file changes with a 500ms delay to coalesce bursts\n  - Delegates to VaultIndex.upsert/upsertIfChanged/remove/rename\n  - Provides proper resource cleanup/unregister methods\n\n- Index module exports (src/indexer/index.ts):\n  - Clean exports for integration (VaultIndex, VaultEventHandler)\n\nDocument Extraction:\n- title: file.basename\n- path: array of directory tokens from dirname split('/').filter(Boolean)\n- headings: from app.metadataCache.getFileCache(file).headings?.map(h => h.heading)\n- tags: union of cache.tags?.map(t => t.tag.replace('#', '')) and normalized cache.frontmatter?.tags (string | string[])\n- symbols: union of:\n  - wiki/markdown links from cache.links?.map(l => l.link)\n  - block refs parsed from body using /\\^[A-Za-z0-9\\-_/]+/g\n  - code labels from fenced code block info strings using /```(\\S+)/g\n- body: via app.vault.read(file); lowercased; fenced code blocks optionally excluded when settings.general.includeCodeBlocks === false\n- mtime, size: from file.stat\n\nPersistence and Incremental Updates:\n- Uses plugin.loadData()/saveData() to persist a map: { path: string: { mtime: number, size: number } }\n- upsertIfChanged consults the cache to skip unchanged files; cache updated only when actual changes occur\n\nEvent Management and Performance:\n- Event handling is centralized in VaultEventHandler with 500ms throttling to handle rapid successive file operations\n- Lazy body indexing: titles/paths indexed first; body extraction queued and processed in batches using requestIdleCallback when available or setTimeout-based chunking\n- Mobile-aware concurrency to avoid long blocking tasks; desktop guarded for potential Worker offloading (feature-flag-ready)\n\nNotes:\n- Provides a robust foundation for search provider integration; integration points exposed via upsert/remove/rename operations and emitted Doc objects",
        "testStrategy": "Comprehensive tests implemented (~25 tests) with mocked Obsidian APIs:\n- Document Extraction: validates title, path tokens, headings, tags (including frontmatter), symbols (links, block refs, code labels), body processing with and without code blocks\n- Incremental Updates: verifies mtime/size cache persists across restarts; upsertIfChanged skips unchanged files; cache updates only on real changes\n- Events and Throttling: create/modify/delete/rename events coalesced by 500ms throttle; metadataCache 'changed' triggers reindex; proper cleanup of handlers\n- Rename Handling: path and title updates reflected; no stale entries left behind\n- Persistence: load/save roundtrip for the mtime/size map; resilience to missing/unknown fields\n- Performance: batching honors mobile-safe chunking; ensures no long blocking tasks; lazy body indexing occurs after initial metadata indexing\n- Error Handling and Type Safety: guards around missing metadataCache fields; type checks pass\n\nRepresentative test files: vault-index.test.ts, event-handler.test.ts (plus supporting utility tests).",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Query parser with filters, phrases, OR/NOT, regex, and commands mode",
        "description": "Robust query parser implemented per PRD with commands mode (prefix), field prefixes (# headings, @ symbols), tag/path filters (tag:value, #value, path:value, in:value), quoted phrases, exclusion terms (-term), OR groups, and validated /regex/flags. Handles empty queries, invalid regex, trailing OR, nested quotes, and mixed content.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "details": "Implementation summary (completed):\n- Mode routing:\n  - If q.trim() starts with the commands prefix and settings.commands.enableCommandsPrefix is true, returns ParsedQuery with mode: 'commands' and preserves raw.\n- Tokenization and parsing:\n  - Extract quoted phrases using /\"([^\"]+)\"/g; supports nested/adjacent quotes by treating each quoted segment as its own phrase; phrases are removed from the residual string before further tokenization.\n  - Extract regex patterns using \\/((?:\\\\\\/|[^\\/])+?)\\/(?:([gimsuy]*))?/; validates via new RegExp(source, flags). On error, records a validation error and ignores the regex in matching.\n  - Split remaining input on whitespace; classify tokens:\n    - Tokens starting with '-' are exclusion terms (excludes array).\n    - Literal 'OR' splits OR groups; trailing OR is tolerated and ignored.\n    - Tag filters: tag:value and #value both add to filters.tag.\n    - Path filters: path:value and in:value populate filters.path or filters.in respectively.\n    - Field-only prefixes: '#' alone sets filters.field = 'headings'; '@' alone sets filters.field = 'symbols'.\n    - All other tokens are terms (terms array).\n  - Always preserve the raw input in the result; collect any parsing/validation errors.\n- OR grouping:\n  - Terms are partitioned into groups separated by OR; empty/trailing groups are ignored without throwing.\n- Highlight regex:\n  - Builds a case-insensitive, word-boundary-aware highlight regex from normalized terms (and phrases) using escape helpers and shared normalize utilities. Example: new RegExp(`(\\\\b(?:${terms.map(esc).join('|')}))`, 'ig').\n  - esc(s) = s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&').\n- Integration points:\n  - Uses ParsedQuery type from types.ts.\n  - Reads relevant options from plugin settings (plugin.ts), including commands mode prefix and enablement.\n  - Exports helpers for regex validation and highlight building for downstream components.\n- Edge cases handled:\n  - Empty queries (produce a valid ParsedQuery with no terms).\n  - Invalid regex flags/patterns (error collected; pattern ignored).\n  - Trailing OR operators.\n  - Nested or adjacent quotes.\n  - Mixed content combining phrases, filters, regex, OR, and excludes.\n- Code locations:\n  - Main implementation: src/search/query-parser.ts\n  - Tests: src/search/query-parser.test.ts\n  - All 62 tests pass, covering core parsing, commands mode, prefixes, filters, phrases, exclusions, OR logic, regex patterns and flags, complex mixed queries, and edge cases.",
        "testStrategy": "Unit tests (src/search/query-parser.test.ts):\n- Commands mode: >cmd prefix obeying settings; mode flips between files and commands.\n- Field prefixes: # (headings), @ (symbols); standalone and combined with other terms.\n- Filters: tag:foo and #foo, path:proj/x, in:Inbox; multiple values and combinations.\n- Phrases: \"exact phrase\"; nested/adjacent quotes treated as separate phrases.\n- Regex: /regex/i and other flags (/pattern/gimsuy); valid patterns included, invalid patterns flagged and ignored with error collection.\n- OR logic: term OR term; multiple groups; trailing OR tolerated.\n- Exclusions: -exclude with other terms and filters.\n- Empty query: returns empty terms with proper defaults and no crashes.\n- Mixed content: combinations of phrases, regex, filters, OR, and excludes.\n- Highlight building: ensures generated regex includes normalized, escaped terms and is case-insensitive.\nAll 62 tests pass, providing comprehensive coverage of parsing behavior, validation, and error handling.",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Scoring model with fuzzy/prefix and recency bonus",
        "description": "Implement fuzzy and prefix scoring per field, configurable weights, diacritic folding, phrase boosts, exclusions, and a recency bonus up to 0.5. Implementation completed with configurable half-life decay, match span generation, and array-field support.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "details": "Implementation completed in:\n- /src/search/scorer.ts — Main scoring implementation and exports\n- /src/search/scorer.test.ts — Comprehensive unit tests (24 tests)\n\nCore algorithm:\n- Overall weighted sum: total = w_title*f(title) + w_headings*f(headings) + w_path*f(path) + w_tags*f(tags) + w_symbols*f(symbols) + w_body*f(body) + recencyBonus(mtime).\n- Default weights: title=4, headings=2, path=1.5, tags=1.5, symbols=1.5, body=1; recency bonus capped at 0.5. All weights configurable via ScorerConfig.\n\nFuzzy/prefix matching:\n- Uses normalizeText from search/normalize.ts; tokenization compatible with /[\\p{L}\\p{N}_-]+/u.\n- Damerau-Levenshtein distance with max distance cap of 2 for performance.\n- Prefix matches score 1.0.\n- Fuzzy score: 1 - dist / max(query.length, text.length), clamped to [0,1].\n- Per-field fuzzy(fieldValue, terms): for each query term, compute max score across field tokens; aggregate as the average across query terms. Supports array fields (e.g., tags, headings, symbols).\n\nPhrase matching and exclusions:\n- Phrase bonus: +0.25 per exact occurrence of a phrase in title/body.\n- Exclusions: if any exclude term matches, the scorer returns null for the document (filtered out upstream).\n\nRecency bonus:\n- Exponential decay with configurable half-life (default 30 days): bonus = clamp(0.5 * exp(-ageDays * ln(2) / halfLifeDays), 0, 0.5).\n- Integrated using doc.mtime.\n\nIntegration points and exports:\n- Consumes Doc, ParsedQuery, and MatchSpan types from search/types.ts.\n- Uses settings.toScorerConfig() (from plugin.ts) to build ScorerConfig.\n- Generates MatchSpan data for highlighting across fields.\n- Exported API provides a scorer factory and scoreDoc compliant with provider usage.\n\nPseudo-code:\nfunction scoreDoc(doc, pq, weights){ let s=0; s += weights.title*f(doc.title); s += weights.headings*f(doc.headings); s += weights.path*f(doc.path); s += weights.tags*f(doc.tags); s += weights.symbols*f(doc.symbols); s += weights.body*f(doc.body); s += recencyBonus(doc.mtime); s += phraseBonuses(doc, pq.phrases); return s }\n",
        "testStrategy": "Unit tests in /src/search/scorer.test.ts (24 tests):\n- Weights: verify weight configuration affects ordering deterministically.\n- Recency: newer docs receive <=0.5 bonus; exponential half-life decay (default 30d) validated; cap enforced.\n- Matching: prefix matches outrank non-prefix fuzzy within the same field; multi-token averaging verified.\n- Diacritics: 'cafe' matches 'café' via normalization.\n- Phrase bonus: +0.25 per phrase occurrence in title/body applied cumulatively.\n- Exclusions: documents containing exclude terms are filtered (scorer returns null).\n- Match spans: highlight spans generated correctly for fields, including arrays.\n- Edge cases: empty docs, unicode, special chars, and distance cap behavior.\nAll tests pass; no regressions in broader suite (205 total tests passing).",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Built-in search provider with inverted index and regex post-filter",
        "description": "Implement BuiltInProvider using a MiniSearch-style inverted index, supporting indexAll, upsert, remove, and query with filters, fuzzy/prefix, weights, and regex applied to top-K candidates.",
        "details": "Implementation:\n- Data structures:\n  - term -> posting list of docIds with per-field term frequency and token positions.\n  - doc store: Map<id, Doc>.\n- Indexing:\n  - For each field (title, path, headings, tags, symbols, body), tokenize normalized values and store positions.\n  - Keep body length cap (e.g., 2MB) to skip huge files.\n- Query:\n  - If empty ParsedQuery and no terms/filters -> return recent notes by mtime desc.\n  - Build candidate set by union across terms with AND semantics enforced by intersection unless pq.orGroups present.\n  - Apply filters: tags, path prefixes, 'in' folder exact or prefix.\n  - For field filter (# or @), restrict scoring to that field.\n  - Score using scorer from task 7; maintain top N by heap up to settings.general.maxResults.\n  - Regex: if pq.regex present, take top K (settings.search.regexCandidateK, default 300), apply RegExp to original body/title; discard non-matching.\n  - Return SearchResult[] with matchSpans for highlighting: for each term found, compute approximate positions from index tokens; for regex, compute match indices.\n- Portability: pure TS, no native binaries; consider vendoring minimal code for Damerau-Levenshtein or implement lightweight version.\nPseudo-code:\nclass BuiltInProvider implements SearchProvider { async indexAll(files){...}; async upsert(file, content){...}; async remove(file){...}; async query(pq, limit){ if (isEmpty(pq)) return recent(); const candidates = gatherCandidates(pq); const scored = scoreAll(candidates); const filtered = applyRegexIfAny(scored); return topN(filtered, limit); } }\n",
        "testStrategy": "Unit (builtInProvider.test.ts):\n- Index docs and ensure deterministic top-k for known queries.\n- Filters: tag, path, in-folder, field-only (#/@) behave as expected.\n- Regex: only applied to top-K; invalid regex ignored.\n- Update: upsert modifies index; remove prunes postings.\n- Empty query returns recent by mtime desc.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Modal UI with results, create/open semantics, commands mode, and preview",
        "description": "Implemented the complete nvALT-like modal UI featuring a single input, results list (with inline snippet and right-side mtime/path), and a bottom preview with multi-fragment highlights and full keyboard navigation and accessibility. Supports file search, commands mode via '>' prefix, recent files on empty input, and robust create/open semantics with path handling.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "details": "Implementation:\n- Architecture (src/modal.ts, ~715 lines): Custom modal with three-section layout — top input, middle results (listbox role), bottom preview pane (fixed height). Real-time search is debounced at 100ms and cancellable via AbortController.\n- Results items:\n  - Files: Left shows Title with an inline snippet (~120 chars) containing <mark>-wrapped highlights; right shows relative modified time and a small folder path.\n  - Commands: Icon (when available), command name, and ID with clean styling.\n  - Click and keyboard selection supported; shows a \"Create [query]\" row when no file results exist.\n- Inline snippet/highlighting: Selects the best-first fragment near the top hit and highlights all query terms using a combined regex; ensures <mark> contrast via CSS vars.\n- Preview pane: Generates up to 3 fragments around matches (merging overlaps), with header showing file title and optional chips (tags/path). ◀ ▶ buttons include aria-labels; Alt+Left/Right cycles fragments. Fallback shows file beginning when no search terms.\n- Commands mode: If input starts with '>', switches to commands; collects via app.commands.listCommands(), fuzzy-filters by name/id, Enter executes via app.commands.executeCommandById(id); Mod+Enter attempts open-in-split when supported (ignored otherwise).\n- Create/Open semantics:\n  - Enter: if matches exist -> open selected; if zero matches -> create Query.md (or explicit path).\n  - Shift+Enter: force-create using current input regardless of matches.\n  - Path support: parse folder/Note; ensure folder exists via app.vault.createFolder before creating; on collision, open existing file.\n  - Open: uses workspace.getLeaf(isSplit) and leaf.openFile(file); Mod+Enter opens in split.\n- Keyboard and focus:\n  - Navigation: Up/Down and J/K (Cmd/Ctrl by platform) move selection.\n  - Actions: Enter to open, Mod+Enter open in split, Shift+Enter force create.\n  - Focus: Tab focuses preview; Esc returns to input; Esc again closes modal.\n  - Fragment cycling: Alt+Left/Right.\n- Empty query: Shows 10 most recent notes by mtime desc.\n- Accessibility: Proper listbox/option roles, aria-selected, focus ring management, descriptive aria-labels on controls, and high-contrast friendly highlights.\n- Performance: 100ms debounce + search cancellation with AbortController; efficient DOM updates. Optional virtualization was deemed unnecessary due to performant rendering.\n- Styling and theming (src/styles.css): Responsive design, dark mode, focus rings, hover/selected states, and accessible contrast for highlights.\n- Integration points (src/plugin.ts): Wires search provider and query parser accessors, and integrates with command execution and hotkey handling.\n- Error handling: Graceful error display with auto-dismiss; collisions and invalid inputs handled without crashing.",
        "testStrategy": "Integration (modal.behavior.test.ts with JSDOM):\n- Debounced search: Typing query updates list within 100ms (use fake timers); pending searches are aborted on rapid input.\n- Create/Open: Enter opens selected match; zero-result shows Create \"{Query}\" row; Shift+Enter force-creates even when matches exist; path creation ensures folders are created; collision opens existing file.\n- Commands mode: Input starting with '>' shows commands; fuzzy filter by name/id; Enter executes stubbed command; Mod+Enter attempts split-open (ignored when unsupported).\n- Keyboard: Arrow Up/Down and J/K (with platform-appropriate modifier) navigate selection; Tab moves focus to preview; Esc returns focus to input; Esc again closes modal; Mod+Enter opens in split; Alt+Left/Right cycles preview fragments.\n- Preview: Generates up to 3 merged fragments; ◀ ▶ buttons have aria-labels; highlights wrap with <mark> and preserve contrast.\n- Accessibility: listbox/option roles on results, aria-selected reflects state, focus ring moves correctly, buttons have accessible names.\n- Recent files: Empty input shows 10 most recent files by mtime desc.\n- Error handling: Invalid query or failures show inline error chip and auto-clear after timeout; no unhandled rejections.\n- Performance sanity: Large result sets render without jank; abort controller cancels superseded searches.\nManual QA:\n- Theme: Verify dark mode and high-contrast themes render highlights legibly.\n- Input methods: Mouse and keyboard interactions; ensure click selection matches keyboard selection.\n- Split open behavior: Validate on different panes/leaves and when command targets are unsupported.",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Test suites (unit and integration) and performance validation",
        "description": "Implement TDD-first automated tests for parser, scorer, snippet/highlight, vault indexer, built-in provider, and modal behaviors; add basic performance harness and acceptance checks. Expand to include: end-to-end tests against a real Obsidian app in an isolated Docker container (driven via Playwright/Electron or Puppeteer), property-based testing with fast-check for parser/scorer/indexer, and Jepsen-style chaos testing to simulate filesystem storms, concurrent queries/updates, plugin reloads, and crash recovery. Establish a comprehensive quality gate spanning unit, integration (JSDOM), E2E, property-based, chaos, and performance tests.",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "details": "Implementation:\n- Vitest config:\n  - Use environment: node for unit, jsdom for integration.\n  - Separate config projects: unit, integration, property (fast-check), and chaos where applicable.\n- Unit tests:\n  - queryParser.test.ts: >cmd, #heading, @symbol, tag:foo, path:x, \"phrase\", /regex/i, OR, -exclude, empty query; include diacritics and escape sequences.\n  - scorer.test.ts: field weights & recency; diacritics; fuzzy vs prefix precedence; phrase boosts; exclusions.\n  - snippet.test.ts: fragment selection, ellipses, overlap merge, HTML escape, <mark> highlights, fragment length bounds (60–240).\n  - vaultIndex.test.ts: add/modify/delete/rename; headings/tags/symbols extraction; includeCodeBlocks toggle; persistence idempotency.\n  - builtInProvider.test.ts: indexAll, upsert, remove, query with deterministic results; regex candidate cap K; empty query recency.\n- Property-based tests (fast-check):\n  - Parser: random token streams with operators, quotes, escapes, and unicode; invariants: parse does not throw; AST nodes satisfy grammar; round-trips preserve semantics where applicable.\n  - Scorer: random documents and queries; invariants: adding a strictly better prefix match does not decrease score; increasing field weight does not lower ordering for that field; recency monotonicity within tolerance; score bounds [0, 1 + recencyCap].\n  - Indexer: random file trees and event sequences (create/modify/rename/delete); invariants: idempotent re-index; rename ≈ delete+add equivalence; tokenization stable under normalization; persistence prevents re-index of unchanged files.\n  - Configure seeds recording and minimal counterexample shrinking.\n- Integration (JSDOM):\n  - modal.behavior.test.ts covering open/create, commands execution, navigation, focus behavior, fragment cycling, zero-result state; DOM snapshots for rows and preview.\n- End-to-End (real Obsidian in Docker):\n  - Container: Dockerfile that installs Node, Playwright dependencies, and launches Obsidian (Electron) via Playwright's Electron launcher (or Puppeteer alternative). Mount an ephemeral test vault and isolated plugin directory to avoid touching user data.\n  - Playwright tests exercise full plugin workflows: enable plugin, initial indexAll, incremental updates on edits, running commands mode, search queries (fuzzy/prefix, tags, paths, regex top-K), opening results, preview/snippet correctness, hotkeys, and settings persistence.\n  - Deterministic seeded vault generation (10k synthetic docs) with fixtures and smaller smoke-set for CI.\n- Chaos tests (Jepsen-style):\n  - Event generator producing adversarial schedules of fs mutations (create/modify/rename/delete storms), concurrent queries, provider reconfiguration, plugin unload/reload, and hard crashes (kill process) followed by restart.\n  - Orchestrator asserts safety/liveness properties: no crashes/panics, index/query consistency (no stale ghost entries, no lost updates), recovery correctness using persisted cache (leveraging Task 5), and bounded staleness under load.\n  - Run in Node integration harness with mocked Obsidian APIs; optionally a smaller E2E chaos suite in Docker for smoke.\n- Performance checks:\n  - Seed 10k synthetic docs; ensure query pipeline returns first results <200ms on desktop env by mocking timers and measuring code path; ensure regex applied to top-K only.\n  - E2E: measure perceived time-to-first-results <300ms using Playwright trace/timing; verify main thread long tasks <50ms chunks in integration and E2E.\n- CI:\n  - Matrix jobs: unit+integration+property on every PR; E2E Docker and chaos smoke on PR; extended chaos/property fuzz and large E2E daily/nightly.\n  - Test artifacts: Playwright traces/videos on failure; chaos event logs and seeds; coverage thresholds ≥80% for core logic.\n  - Flake management: retries with preserved seeds and deterministic re-runs.\n- Acceptance mapping: ensure all 8 PRD acceptance bullets covered across integration and E2E suites.",
        "testStrategy": "Execution:\n- Local dev: run vitest in watch mode for unit/integration; run fast-check with fixed seed during TDD and random seeds in CI. Re-run failing property tests with saved seed and shrunk counterexample.\n- E2E: run Playwright against Dockerized Obsidian Electron app with an ephemeral test vault; collect traces/videos; avoid touching host Obsidian by using isolated container volumes.\n- Chaos: run orchestrated scenarios with reproducible seeds; capture event timelines and invariant assertions; provide a smoke subset for PR gating and a longer suite nightly.\n- Snapshots: include DOM snapshots for modal rows and preview; validate no regressions in structure/highlights.\n- Mobile simulation: throttle timers and CPU in integration/E2E to verify no long blocking tasks (>50ms chunks).\n- Performance budgets: assert unit/integration micro-benchmarks and E2E time-to-first-results budgets; verify regex is only applied to top-K candidates.\n- Acceptance criteria: map each PRD acceptance bullet to explicit tests in integration/E2E; require all to pass in CI.",
        "subtasks": [
          {
            "id": 1,
            "title": "Add fast-check property-based test harness for parser, scorer, and indexer",
            "description": "Introduce fast-check to the test stack, implement seeds recording, and write core property suites covering parser grammar invariants, scorer monotonicity/weighting/recency, and indexer idempotency/rename equivalence/persistence invariants.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create Dockerized E2E environment and Playwright harness for Obsidian",
            "description": "Author a Dockerfile and scripts to run Obsidian (Electron) under Playwright inside a container with an ephemeral test vault and isolated plugin folder. Implement Playwright tests that drive real UI and verify end-to-end plugin workflows.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Jepsen-style chaos testing orchestrator",
            "description": "Build a scenario runner that generates adversarial filesystem event schedules, concurrent queries/updates, plugin reloads, and crash/restart sequences. Define and assert safety/liveness invariants; emit detailed logs and reproducible seeds.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Extend performance harness and E2E timing assertions",
            "description": "Add timing probes and budgets in unit/integration for sub-200ms first results; extend E2E to assert <300ms perceived time-to-first-results and no >50ms long tasks; verify regex is applied to top-K only.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "CI pipeline updates for multi-tier quality gates",
            "description": "Configure CI matrix with unit/integration/property on PR, E2E and chaos smoke on PR, and full fuzz/chaos/E2E nightly. Upload artifacts (traces/videos/logs), enforce ≥80% coverage for core logic, and enable flaky test retries with preserved seeds.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Fixtures and synthetic data generators",
            "description": "Provide deterministic generators for synthetic vaults (up to 10k docs), smaller smoke sets, and reusable fixtures for E2E and property tests; include diacritics, regex-heavy content, and large bodies.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Contributor docs for running tests locally",
            "description": "Document how to run unit/integration/property tests, spin up Docker E2E, interpret Playwright artifacts, reproduce property/chaos failures via saved seeds, and update snapshots.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 11,
        "title": "Documentation and UX Adoption Package: README, Docs Suite, Example Vault, and Media Assets",
        "description": "Produce a complete documentation and onboarding package to maximize adoption: a professional README, full docs suite, curated example vault, and high-quality media (GIF/MP4/screenshots) that demonstrate key workflows and advanced capabilities.",
        "details": "Scope and deliverables\n- README (root): concise value proposition, hero GIF, quick start, installation, key features, configuration overview, link to docs, troubleshooting link, feature comparison summary, and badges (version, downloads, license). Include animated GIFs for: open/create, search filters/modes (#, @, tag:, path:, phrase, regex), commands mode, and preview pane.\n- Docs suite (docs/):\n  - user-guide.md: first-run, invoking the modal, searching, opening/creating files, commands mode, preview usage.\n  - advanced-config.md: weights tuning tied to scorer (fields, recency half-life), fuzzy/prefix behavior, hotkeys and commands mapping, index size limits, performance tips.\n  - troubleshooting.md: empty results, slow indexing/search, regex errors, snippet/highlight issues, mobile-specific considerations, resetting cache/index.\n  - migration.md: from core Quick Switcher, Omnisearch, Another Quick Switcher; keybinding parity; before/after comparisons; tips for replicating common workflows.\n  - features-comparison.md: fair, criteria-based comparison (capabilities, performance, UX) with clear date and version disclaimers.\n  - faq.md: common questions (privacy of index, large files, folders to include/exclude, regex safety, case/diacritics).\n- Example Vault (examples/demo-vault/): 50–120 realistic notes with folders (Inbox, Projects, Areas, Resources, Archive), tags (YAML and inline), headings at multiple levels, code blocks, symbols-like sections (e.g., function definitions), links, attachments. Include a few large files to showcase indexing limits and recency-spread mtimes. Provide seed script (scripts/seed-demo-vault.{ts|js}) to set mtimes and generate synthetic but meaningful content and tags.\n- Media assets (media/): screen recordings as MP4 and optimized GIFs, screenshot gallery (light/dark), configuration screenshots (settings tabs, weights, hotkeys), and before/after comparisons with other workflows. Name files predictably: flow-<topic>-<light|dark>.<gif|mp4|png>.\n\nImplementation plan\n1) Information architecture\n- Define audience pathways: New User (Quick Start in README + user-guide.md) and Power User (advanced-config.md + commands and regex examples).\n- Set consistent terminology that matches UI labels and parser terminology.\n\n2) Example vault creation\n- Write curated notes: meeting notes, project specs, code snippets, recipes, journal entries; embed realistic headings, tags (#project/x, #person, #priority/high), symbols-like patterns (@function foo(), class Bar), and varied body text.\n- Add search edge cases: diacritics, pluralization, hyphenated terms, quoted phrases, negative terms, regex-worthy content; include tag collisions and similar titles.\n- Include folder/path filters examples (in:Resources, path:Projects/2025), and a few notes with very recent and very old mtimes; commit seed script to regenerate.\n\n3) Recording and asset pipeline\n- Prepare a clean Obsidian profile with only this plugin enabled; install plugin build; load example vault.\n- Recording guidelines: 1440p or 1080p, 60 fps capture; show keystrokes overlay; keep each clip 6–15s; trim idle time; prefer zoomed UI scale 110–125%.\n- Export MP4 (H.264, CRF ~20) and generate GIFs (ffmpeg -> gifski) targeting <=4–8 MB each; loop seamlessly; include captions where helpful.\n- Record flows: open existing note, create on Shift+Enter, commands mode (>), filters (#, @, tag:, path:, in:), phrase vs regex, preview multi-fragment highlights, weights tweak effect on ordering, before/after vs core Quick Switcher.\n- Capture static screenshots in both light/dark themes; include settings panels (weights, hotkeys, indexing options).\n\n4) Authoring documentation\n- Use Markdown with frontmatter titles; store under docs/ with relative links to media/ and examples/.\n- Provide copy-paste-ready snippets for settings JSON or in-app settings with annotated screenshots for weights tuning and hotkeys.\n- Write step-by-step troubleshooting flows with decision trees and exact menu paths; include log locations and how to enable debug mode if available.\n- Construct features-comparison.md with a dated matrix of criteria (query language coverage, regex support, preview/snippets, recency, fuzzy/prefix, commands, performance, mobile compatibility); include methodology and fairness notes.\n\n5) Tooling and CI\n- Add npm scripts: docs:serve (local preview), docs:check (markdown-link-check, spellcheck), media:optimize (imagemin/gifsicle), vault:seed.\n- Optionally publish docs to GitHub Pages (or keep in-repo only); skip if out of scope.\n- Pre-commit hook to prevent >10 MB assets and enforce alt text for images.\n\n6) Packaging and release\n- Include README hero GIF and quick-start steps; link to docs and example vault.\n- Zip and attach examples/demo-vault to release assets; note usage instructions.\n- Add CHANGELOG link and Support/Issues links.\n\nAccessibility and inclusivity\n- Provide alt text for all images and concise captions; avoid color-only distinctions; include keyboard sequences in text; ensure GIFs are not flashing rapidly and include MP4 alternatives.\n\nQuality bars\n- Zero broken links; media under size budgets; docs accurately reflect implemented UI and behavior; reproducible example vault; quick start under 2 minutes from install to first search.",
        "testStrategy": "Content accuracy\n- Use the example vault to reproduce every screenshot/GIF. Verify each documented workflow works on the current build: open, create, commands mode, filters (#, @, tag:, path:, in:), phrase, regex, preview highlights, and weight tuning changes affecting result order.\n- Cross-check query syntax in docs against the parser behavior (Task 6) including error cases (invalid regex) and empty query recency behavior.\n- Validate scoring examples and weight tuning outcomes against the scorer (Task 7) by setting example weights and confirming ordering changes in the modal.\n\nMedia and assets\n- Lint docs: run markdown-link-check over README and docs; ensure no broken anchors or media paths.\n- Verify alt text present for all images; GIFs have MP4 equivalents; each GIF < 8 MB and MP4 < 20 MB; filenames follow naming scheme.\n- Open assets on Windows, macOS, and Linux to ensure legibility in light and dark themes.\n\nExample vault\n- Run the seed script to regenerate; confirm mtimes are applied and index reflects headings, tags, symbols, and body content. Ensure at least 10 target queries used in docs return the same top-3 results as shown in media.\n\nUsability checks\n- Fresh profile test: time from install to first successful search < 2 minutes following README.\n- Power user path: follow advanced-config steps to change weights and assign a hotkey; confirm docs steps match exact UI labels and settings paths.\n\nCompliance and fairness\n- Review features-comparison.md for neutrality, date-stamp, and clear methodology. Verify all claims with reproducible steps in the example vault.\n\nCI and automation\n- Run npm run docs:check to ensure link and spell checks pass. Reject commit if any media exceeds size thresholds or links are broken.",
        "status": "pending",
        "dependencies": [
          6,
          7,
          8,
          9
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Community Plugin Submission, Release Automation, and Launch Campaign",
        "description": "Prepare and submit the plugin to the Obsidian community directory with a robust CI-driven release pipeline and a coordinated launch plan across official channels.",
        "details": "Scope overview\n- Plugin store preparation: finalize manifest.json, produce release artifacts (main.js, styles.css, manifest.json), tag v1.0.0, and verify manual installation.\n- Community submission: fork obsidian-releases, add plugin entry to community-plugins.json, open PR with required metadata, and handle review feedback.\n- Release infrastructure: GitHub Actions for build/test/release, semantic versioning policy, release notes template, and an in-plugin update notification.\n- Community engagement: announcement plan for Discord, Reddit, Obsidian Forum, and social media assets.\n\n1) Preflight and compliance (Obsidian guidelines)\n- Manifest fields: id (kebab-case, unique), name, version (SemVer), minAppVersion, description (concise, benefits-focused), author, authorUrl, fundingUrl (ko-fi/patreon/GitHub Sponsors), isDesktopOnly (as needed). Ensure id matches the folder name users will install.\n- Licensing: add LICENSE (MIT or compatible). Add NOTICE if needed.\n- Repo hygiene: README with installation instructions and links to docs (leveraging Task 11), topics: obsidian-plugin.\n- Packaging layout for release: the three files must be at the root of each GitHub Release (no nested folders): main.js, manifest.json, styles.css (optional).\n\n2) Release automation (GitHub Actions)\n- Choose SemVer strategy: conventional commits + Changesets (recommended) or semantic-release. Document policy: Breaking = major, Features = minor, Fixes/docs/chore = patch.\n- Action: .github/workflows/release.yml\n  - Triggers: on push of tags matching v*.*.*; on main push run tests only.\n  - Steps:\n    - checkout\n    - setup-node: use matrix Node LTS; cache pnpm/yarn/npm.\n    - install deps\n    - run build to emit main.js and styles.css to repo root or ./dist with a copy step to root\n    - run unit/integration tests (if present); fail release on test failure\n    - validate manifest.json against schema (simple jq checks or a small Node script)\n    - create GitHub Release and upload assets using softprops/action-gh-release or gh cli\n    - generate release notes from commits (changesets/action or release-drafter)\n- Sample snippet (simplified):\n  name: release\n  on:\n    push:\n      tags: [\"v*.*.*\"]\n  jobs:\n    build-and-release:\n      runs-on: ubuntu-latest\n      steps:\n        - uses: actions/checkout@v4\n        - uses: actions/setup-node@v4\n          with: { node-version: 20 }\n        - run: corepack enable && pnpm i --frozen-lockfile\n        - run: pnpm build\n        - run: node scripts/validate-manifest.js\n        - uses: softprops/action-gh-release@v2\n          with:\n            files: |\n              manifest.json\n              main.js\n              styles.css\n          env:\n            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n3) Manual installation test (QA gate)\n- Download the GitHub Release assets (exact versions you intend to submit).\n- Create a fresh test vault: .obsidian/plugins/<plugin-id>/\n- Place main.js, manifest.json, styles.css in that folder.\n- Launch Obsidian, enable the plugin, verify no console errors, confirm core workflows:\n  - Open the modal, search, create/open note behavior, commands mode, filters, preview rendering.\n- Record environment (OS, Obsidian version) and attach to the release QA checklist.\n\n4) Community directory submission\n- Fork obsidianmd/obsidian-releases.\n- Add plugin entry to community-plugins.json (example):\n  { \"id\": \"your-plugin-id\", \"repo\": \"your-org/your-repo\" }\n- Commit message: chore: add your-plugin-id to community plugins\n- PR description must include:\n  - One-line value proposition\n  - Links: repo, README, docs, release tag, minimum app version, funding URL\n  - Screenshots/GIF (from Task 11) and manual install verification notes\n- Run the repo’s validation (CI will run on PR). Fix any feedback (naming, missing assets, manifest issues). If requested, cut a patch release and update PR.\n\n5) Update notification inside the plugin\n- Store lastSeenVersion in plugin’s data.\n- On load, compare manifest.version to lastSeenVersion; if changed, show a Notice with link to CHANGELOG or GitHub Release and a command “Show What’s New”.\n- Pseudocode:\n  const current = manifest.version;\n  const last = this.settings.lastSeenVersion;\n  if (last !== current) {\n    new Notice(`Plugin updated to ${current}. See what's new →`);\n    this.settings.lastSeenVersion = current;\n    await this.saveSettings();\n  }\n\n6) Release notes and changelog\n- Add .github/release.yml or release-drafter config to group changes: Features, Fixes, Performance, Docs, Chore.\n- Maintain CHANGELOG.md (changesets can auto-update). Link to it from README and the in-app notice.\n\n7) Community engagement plan\n- Discord: prepare post for #plugin-releases with hero GIF, core features bullets, install steps, and link to community listing and docs.\n- Reddit r/ObsidianMD: announcement with problem-solution framing, GIFs, feature list, and Q&A comment reserved.\n- Obsidian Forum: post template (features, setup, known limitations, roadmap) and reply-watch enabled.\n- Social media assets: 1200x630 OG image for repo/docs; short MP4/GIF clips cropped for platforms; concise copy variants (tweet/thread, toot, LinkedIn).\n- Schedule: coordinate posts within 24–48h of PR merge; monitor and respond to feedback/issues.\n\n8) Safeguards and support\n- Security: run npm audit (or pnpm audit) and license check; pin dependencies where needed.\n- Issue templates: bug report, feature request; Discussions enabled.\n- Telemetry: none by default; document any optional analytics explicitly if ever added.\n\nDeliverables\n- Passing release CI producing assets for v1.0.0.\n- PR to obsidian-releases with green checks.\n- Update-notice feature merged.\n- Launch posts (Discord, Reddit, Forum) ready as markdown drafts in /launch/ with media files.\n- Submission/QA checklist completed and committed at /docs/submission-checklist.md.",
        "testStrategy": "Preflight checklist\n- Manifest validation: verify required keys exist and are correct (id, name, version SemVer, minAppVersion, description, author, authorUrl, fundingUrl, isDesktopOnly). Run scripts/validate-manifest.js and ensure it exits 0.\n- License and README present; README includes installation, features, links.\n\nCI verification\n- On a dry-run tag (e.g., v1.0.0-rc.1), confirm GitHub Actions:\n  - Installs deps, runs build, and uploads exactly three assets at release root.\n  - Fails if tests fail (if test suite exists). Capture artifacts in run summary.\n  - Generates release notes with correct sections.\n\nManual install QA\n- Using a clean vault, install from the release assets and enable the plugin.\n- Validate flows end-to-end: open modal, search, filters (tag, path, in, headings/symbols), commands mode, preview highlights, create/open semantics.\n- Confirm no console errors or unhandled promise rejections.\n- Test on at least two OSes (e.g., macOS + Windows) and Obsidian minAppVersion and latest.\n\nSubmission PR checks\n- Run JSON lint on community-plugins.json change; ensure id matches manifest.id and repo slug is correct.\n- Open PR to obsidian-releases; verify PR CI passes (schema/format checks) and the PR description contains required info.\n- Address any reviewer comments within 48h; if a code change is requested, ship a patch (v1.0.1) and re-run manual install QA.\n\nUpdate notification tests\n- Upgrade path: set lastSeenVersion to prior version in settings, reload plugin with newer manifest.version; confirm Notice appears and command \"Show What’s New\" opens changelog.\n- No-op path: if versions match, no Notice is shown.\n\nLaunch assets validation\n- Check all links in Discord/Reddit/Forum drafts resolve (community listing, docs, releases, funding).\n- Ensure hero GIF and images load quickly (<2MB preferred) and are readable in dark/light mode.\n\nRollback plan\n- If critical issue found post-merge, publish v1.0.1 within 2 hours; update posts with fix note; keep community PR unchanged (listing auto-follows latest release).",
        "status": "pending",
        "dependencies": [
          8,
          9,
          11
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Smart Multi‑Level Caching for BuiltInProvider (Query, Intersection, and Expansion Caches)",
        "description": "Implement an internal multi-level caching layer in the BuiltInProvider to accelerate repeated and similar queries, including LRU query result caching, posting-list intersection caching, and fuzzy/prefix expansion memoization with robust invalidation. Design the caches to be engine-agnostic and WASM-ready so they can be reused or safely bypassed by a future Rust/WASM-backed provider without API churn.",
        "status": "pending",
        "dependencies": [
          4,
          6,
          8
        ],
        "priority": "medium",
        "details": "Scope and goals\n- Target 5–20x speedups for repeated/similar queries and reduce CPU work per keystroke.\n- Implement in TypeScript/JavaScript and ensure cross‑platform compatibility (desktop and mobile, including iOS). Avoid Node-only APIs.\n- Preserve exact result equivalence with uncached execution and ensure correctness under live index mutations.\n- WASM-ready: structure cache interfaces and keys so a future Rust/WASM provider can plug in with the same semantics or selectively disable layers it implements internally. Do not implement WASM in this task.\n\nComponents\n1) QueryResultCache (LRU)\n- Key: stable QueryKey derived from ParsedQuery + limit + scoring config that affects ranking.\n  - Includes: mode, normalized terms (lowercased, diacritics-folded, sorted), phrases (sorted), excludes, filters (tag/path/in/field sorted and canonicalized), fuzzy/prefix flags, limit K, weights (field weights, recency), and a timeBucket when recency weighting is enabled (e.g., floor(nowMs/60_000)).\n  - Engine tag: include an optional engineTag (e.g., 'js-builtin-v1' by default) to segregate caches across different search engines (future WASM implementation) while keeping ranking-equivalence assumptions. Provider supplies this tag.\n  - Excludes: index-generation; store it in value to validate freshness.\n- Value: { generation: number; results: SearchResult[]; stats?: { buildMs:number; size:number } }.\n- Policy: LRU with a bounded capacity (e.g., 200 entries) and optional TTL (e.g., 5 minutes). Provide internal defaults; optionally read overrides from settings if present, but do not require new settings.\n- In-flight de-duplication: maintain a Map<QueryKey, Promise<SearchResult[]>> so concurrent identical queries share work.\n- When regex is present: cache only if regex is part of the key. If regex is too broad (e.g., empty or trivial), skip result caching but keep intersection caching (below).\n\n2) IntersectionCache (LRU)\n- Purpose: cache expensive candidate computations (union/AND of postings across terms and filters) before scoring.\n- Key: canonicalized tuple of token IDs (post-tokenization/fuzzy/prefix expansion), AND/OR structure, field filter, and tag/path/in filters. Sort where commutative, preserve order where it changes semantics (e.g., OR groups). Include engineTag for future engine segregation.\n- Value: sorted array (or typed array) of candidate docIds plus the index generation used.\n- Capacity: e.g., 1000 entries; evict via LRU.\n- Updates: if index generation changes, treat entry as stale and recompute on next access (lazy invalidation).\n- Safety: cap to 20k docIds per entry; skip caching larger intersections to avoid memory blow-ups.\n\n3) ExpansionCache (LRU)\n- Purpose: memoize fuzzy/prefix expansions and quick TF/DF estimates per term to avoid re-computing expansions every keystroke.\n- Key: { term, field?, fuzzyParams, prefixParams, engineTag? }.\n- Value: { expandedTerms: string[]; dfEstimate:number }.\n- Capacity: e.g., 2000 entries; TTL: short (e.g., 2 minutes).\n\n4) Index-generation and invalidation\n- Maintain an indexGeneration number in BuiltInProvider increased on upsert/remove/indexAll completion.\n- Each cache entry stores the generation used to build it. On read: if entry.generation !== currentGeneration, treat as miss and recompute (write-through with new generation).\n- On settings affecting scoring/filters/fuzzy thresholds or weights change: flush all caches.\n- On timer tick for recency-weighting drift: either use time buckets in QueryKey or expire QueryResultCache entries that used a prior bucket.\n\n5) Query execution changes\n- Normalize ParsedQuery into a CanonicalQuery (remove duplicates, sort commutative components, normalize diacritics) prior to cache lookup to maximize hit rate.\n- Pipeline:\n  1. Build QueryKey and check QueryResultCache (respect in-flight dedupe).\n  2. If miss: resolve fuzzy/prefix via ExpansionCache, then fetch posting lists; consult IntersectionCache for candidate sets.\n  3. Score candidates; consider memoizing small per-doc partials per query execution only (ephemeral map) to avoid cross-query memory bloat.\n  4. Post-filter with regex (if supplied) then slice top-K.\n  5. Save results to QueryResultCache.\n\n6) Memory and safety constraints\n- Use lightweight custom LRU (Map + doubly-linked list) to avoid extra deps. Track counts (entries) rather than bytes for simplicity.\n- Hard cap candidates cached to prevent pathological keys (e.g., cap to 20k docIds per entry; skip caching larger intersections).\n- Avoid caching empty/invalid queries; return early.\n- Mobile-friendly defaults: use conservative default capacities on mobile (e.g., 50/400/800 for Query/Intersection/Expansion) when environment is mobile; allow override via settings if present.\n\n7) Telemetry and diagnostics (dev-only)\n- Optional counters: cache hits/misses per layer, evictions, in-flight coalescing count, and average build times. Log only under a development flag.\n- Include engineTag in diagnostics to verify segregation when engines differ.\n\n8) WASM readiness and threading\n- Engine-agnostic interfaces: keep canonicalization, key derivation, and caches in their own modules that accept engineTag and generation providers, so a future WASM engine can reuse or bypass them cleanly.\n- Threading: caches should be scoped to the provider instance and not shared across threads. If the provider runs in a Worker, caches must work unchanged (no DOM/Node APIs, no SharedArrayBuffer requirement). Use only standard JS constructs compatible with Obsidian desktop and mobile.\n\nExample skeletons\n- QueryKey derivation:\n  function makeQueryKey(pq: ParsedQuery, limit: number, cfg: ScoringCfg, engineTag='js-builtin-v1', now=Date.now()): string {\n    const timeBucket = cfg.useRecency ? Math.floor(now / 60000) : 0;\n    const norm = canonicalizeParsedQuery(pq);\n    return JSON.stringify({\n      m: norm.mode,\n      t: norm.terms,\n      ph: norm.phrases,\n      ex: norm.excludes,\n      f: norm.filters,\n      fld: norm.field,\n      fu: norm.fuzzy,\n      pr: norm.prefix,\n      k: limit,\n      w: cfg.weightsHash,\n      tb: timeBucket,\n      e: engineTag,\n    });\n  }\n- LRU minimal shape:\n  class Lru<K,V> { /* set/get/has/delete with capacity, recency list, and optional TTL */ }\n\nNon-goals\n- Do not alter ranking semantics versus the current provider.\n- Do not persist caches across sessions; keep in-memory only.\n- Do not implement a WASM search engine in this task; only ensure the cache system does not preclude it.\n\nDeliverables\n- src/search/cache/{lru.ts, query-cache.ts, intersection-cache.ts, expansion-cache.ts}\n- Integration into BuiltInProvider: cache hooks at candidate build and final result stages; generation tracking; settings change listeners.\n- Engine-agnostic canonicalization/key helpers exported (e.g., src/search/canonicalize.ts) with engineTag support.\n- Dev-only diagnostics exported behind a feature flag.",
        "testStrategy": "Unit tests\n- QueryResultCache correctness: same ParsedQuery and limit returns identical results on second call without invoking the heavy scoring path. Instrument internal counters to assert cache hits vs misses (no timing assertions).\n- Key normalization: queries with reordered terms/filters (e.g., `tag:x y` vs `y tag:x`) produce the same QueryKey and hit the same cache entry.\n- Regex behavior: with regex queries, verify policy (cache enabled/disabled as specified). Ensure candidates intersection still uses IntersectionCache.\n- Recency-sensitive caching: when recency weighting is enabled, verify timeBucket grouping—within same bucket, hits; across buckets, miss.\n- LRU eviction: fill cache beyond capacity and ensure oldest entries are evicted and recomputed.\n- In-flight de-duplication: dispatch two concurrent identical queries; verify only one execution runs and both callers receive the same Promise result.\n- IntersectionCache: construct multi-term AND/OR queries and confirm candidate sets are cached; mutate index (generation++) and confirm lazy invalidation on next access.\n- ExpansionCache: repeated fuzzy/prefix term expansions hit cache; index mutation invalidates expansions if necessary (generation mismatch policy).\n- Mutation invalidation: after upsert/remove, ensure cached QueryResultCache entries built on prior generation are treated as stale (miss and recompute). Confirm no stale results returned.\n- Safety caps: verify oversized candidate sets are not cached and do not crash. Ensure empty/invalid queries bypass caches.\n- Engine tag segregation: with different engineTag values, ensure caches do not cross-contaminate (miss across tags, hit within tag). Default tag 'js-builtin-v1'.\n- Mobile-safe: ensure no Node-only APIs are referenced; basic environment shim test to confirm code paths avoid platform-specific features.\n\nIntegration tests\n- Wire caches into BuiltInProvider and run the existing provider tests to ensure results are unchanged.\n- Typing simulation: simulate keystrokes that build up a query (p, pr, pro, proj, proje, project). Verify increasing cache hit rate across layers and reduced heavy-path invocations via counters.\n- Settings changes: toggling field weights or fuzzy thresholds flushes caches; subsequent queries are misses followed by hits.\n- Worker compatibility (if provider can run in a worker): run provider in a worker-like test harness and verify caches behave identically (no shared state leaks, no DOM/Node assumptions).\n\nPerformance validation (non-flaky)\n- Micro-benchmark harness: run a fixed doc corpus (e.g., 5k synthetic docs) and measure per-query internal counters to confirm reduced work. Allow wide timing tolerances; assert at least 5x fewer scoring calls on repeated queries.\n- Memory: create many distinct cache entries then force GC-friendly conditions; assert entry counts respect capacity and eviction operates without leaks (via weak invariants and counters).",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement LRU base with TTL and capacity controls",
            "description": "Build src/search/cache/lru.ts with Map + doubly-linked list, optional TTL, and unit-tested set/get/has/delete semantics. No Node-specific APIs.",
            "status": "todo",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "QueryResultCache with in-flight de-duplication and engineTag-aware keys",
            "description": "Implement src/search/cache/query-cache.ts using makeQueryKey(canonicalize + engineTag). Support timeBucket, TTL, capacity, and Promise coalescing.",
            "status": "todo",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "IntersectionCache with candidate cap and generation-aware invalidation",
            "description": "Implement src/search/cache/intersection-cache.ts caching candidate docId sets keyed by canonicalized token structures, filters, and engineTag. Enforce 20k doc cap and lazy invalidation on generation mismatch.",
            "status": "todo",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "ExpansionCache for fuzzy/prefix memoization",
            "description": "Implement src/search/cache/expansion-cache.ts with short TTL and keys including term, field, fuzzy/prefix params, and engineTag. Return expandedTerms and dfEstimate.",
            "status": "todo",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Canonicalization and key helpers (engine-agnostic)",
            "description": "Extract canonicalizeParsedQuery and makeQueryKey into src/search/canonicalize.ts. Include engineTag parameter and ensure deterministic JSON serialization.",
            "status": "todo",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Integrate caches into BuiltInProvider with generation tracking and settings listeners",
            "description": "Wire QueryResultCache, IntersectionCache, and ExpansionCache into the provider pipeline. Maintain indexGeneration, flush on relevant settings changes, and expose dev-only diagnostics.",
            "status": "todo",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Threading and mobile compatibility pass",
            "description": "Verify caches work when provider runs in a Worker and on mobile/iOS. Ensure no DOM/Node APIs, and scope caches to provider instances to avoid cross-thread sharing.",
            "status": "todo",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Unit and integration tests per testStrategy",
            "description": "Add comprehensive tests including engineTag segregation, LRU eviction, in-flight dedupe, generation invalidation, and typing simulation hit rates.",
            "status": "todo",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-21T01:58:07.396Z",
      "updated": "2025-08-21T06:08:44.999Z",
      "description": "Tasks for master context"
    }
  }
}